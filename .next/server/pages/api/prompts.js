"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/prompts";
exports.ids = ["pages/api/prompts"];
exports.modules = {

/***/ "(api-node)/./lib/auth-utils.js":
/*!***************************!*\
  !*** ./lib/auth-utils.js ***!
  \***************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateToken: () => (/* binding */ generateToken),\n/* harmony export */   hashPassword: () => (/* binding */ hashPassword),\n/* harmony export */   verifyPassword: () => (/* binding */ verifyPassword)\n/* harmony export */ });\n/* harmony import */ var bcryptjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bcryptjs */ \"bcryptjs\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_1__);\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([bcryptjs__WEBPACK_IMPORTED_MODULE_0__]);\nbcryptjs__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n/**\n * Hash a password using bcrypt\n * @param {string} password - Plain text password to hash\n * @returns {Promise<string>} - Hashed password\n */ const hashPassword = async (password)=>{\n    const salt = await bcryptjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].genSalt(12);\n    return bcryptjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hash(password, salt);\n};\n/**\n * Verify a password against a hash\n * @param {string} password - Plain text password to check\n * @param {string} hash - Hashed password to compare against\n * @returns {Promise<boolean>} - True if password matches hash\n */ const verifyPassword = async (password, hash)=>{\n    return bcryptjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].compare(password, hash);\n};\n/**\n * Generate a random token (e.g., for email confirmation, password reset)\n * @param {number} length - Length of the token\n * @returns {string} - Random token\n */ const generateToken = (length = 32)=>{\n    return crypto__WEBPACK_IMPORTED_MODULE_1___default().randomBytes(length).toString('hex');\n};\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uL2xpYi9hdXRoLXV0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUE4QjtBQUNGO0FBRTVCOzs7O0NBSUMsR0FDTSxNQUFNRSxlQUFlLE9BQU9DO0lBQ2pDLE1BQU1DLE9BQU8sTUFBTUosd0RBQWMsQ0FBQztJQUNsQyxPQUFPQSxxREFBVyxDQUFDRyxVQUFVQztBQUMvQixFQUFFO0FBRUY7Ozs7O0NBS0MsR0FDTSxNQUFNRyxpQkFBaUIsT0FBT0osVUFBVUc7SUFDN0MsT0FBT04sd0RBQWMsQ0FBQ0csVUFBVUc7QUFDbEMsRUFBRTtBQUVGOzs7O0NBSUMsR0FDTSxNQUFNRyxnQkFBZ0IsQ0FBQ0MsU0FBUyxFQUFFO0lBQ3ZDLE9BQU9ULHlEQUFrQixDQUFDUyxRQUFRRSxRQUFRLENBQUM7QUFDN0MsRUFBRSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxiYXVkaVxcT25lRHJpdmVcXERlc2t0b3BcXFByb21wdFByb1xcUHJvbXB0UHJvXFxsaWJcXGF1dGgtdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGJjcnlwdCBmcm9tICdiY3J5cHRqcyc7XG5pbXBvcnQgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5cbi8qKlxuICogSGFzaCBhIHBhc3N3b3JkIHVzaW5nIGJjcnlwdFxuICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIC0gUGxhaW4gdGV4dCBwYXNzd29yZCB0byBoYXNoXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSAtIEhhc2hlZCBwYXNzd29yZFxuICovXG5leHBvcnQgY29uc3QgaGFzaFBhc3N3b3JkID0gYXN5bmMgKHBhc3N3b3JkKSA9PiB7XG4gIGNvbnN0IHNhbHQgPSBhd2FpdCBiY3J5cHQuZ2VuU2FsdCgxMik7XG4gIHJldHVybiBiY3J5cHQuaGFzaChwYXNzd29yZCwgc2FsdCk7XG59O1xuXG4vKipcbiAqIFZlcmlmeSBhIHBhc3N3b3JkIGFnYWluc3QgYSBoYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgLSBQbGFpbiB0ZXh0IHBhc3N3b3JkIHRvIGNoZWNrXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFzaCAtIEhhc2hlZCBwYXNzd29yZCB0byBjb21wYXJlIGFnYWluc3RcbiAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSAtIFRydWUgaWYgcGFzc3dvcmQgbWF0Y2hlcyBoYXNoXG4gKi9cbmV4cG9ydCBjb25zdCB2ZXJpZnlQYXNzd29yZCA9IGFzeW5jIChwYXNzd29yZCwgaGFzaCkgPT4ge1xuICByZXR1cm4gYmNyeXB0LmNvbXBhcmUocGFzc3dvcmQsIGhhc2gpO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHJhbmRvbSB0b2tlbiAoZS5nLiwgZm9yIGVtYWlsIGNvbmZpcm1hdGlvbiwgcGFzc3dvcmQgcmVzZXQpXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIC0gTGVuZ3RoIG9mIHRoZSB0b2tlblxuICogQHJldHVybnMge3N0cmluZ30gLSBSYW5kb20gdG9rZW5cbiAqL1xuZXhwb3J0IGNvbnN0IGdlbmVyYXRlVG9rZW4gPSAobGVuZ3RoID0gMzIpID0+IHtcbiAgcmV0dXJuIGNyeXB0by5yYW5kb21CeXRlcyhsZW5ndGgpLnRvU3RyaW5nKCdoZXgnKTtcbn07Il0sIm5hbWVzIjpbImJjcnlwdCIsImNyeXB0byIsImhhc2hQYXNzd29yZCIsInBhc3N3b3JkIiwic2FsdCIsImdlblNhbHQiLCJoYXNoIiwidmVyaWZ5UGFzc3dvcmQiLCJjb21wYXJlIiwiZ2VuZXJhdGVUb2tlbiIsImxlbmd0aCIsInJhbmRvbUJ5dGVzIiwidG9TdHJpbmciXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api-node)/./lib/auth-utils.js\n");

/***/ }),

/***/ "(api-node)/./lib/auth.js":
/*!*********************!*\
  !*** ./lib/auth.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAuthSession: () => (/* binding */ getAuthSession),\n/* harmony export */   withAuth: () => (/* binding */ withAuth),\n/* harmony export */   withAuthForMethods: () => (/* binding */ withAuthForMethods)\n/* harmony export */ });\n/* harmony import */ var next_auth_jwt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next-auth/jwt */ \"next-auth/jwt\");\n/* harmony import */ var next_auth_jwt__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_auth_jwt__WEBPACK_IMPORTED_MODULE_0__);\n\n/**\r\n * Check if the request is authenticated\r\n * @param {Object} req - The request object\r\n * @returns {Promise<Object|null>} - The user session or null if not authenticated\r\n */ async function getAuthSession(req) {\n    return await (0,next_auth_jwt__WEBPACK_IMPORTED_MODULE_0__.getToken)({\n        req,\n        secret: process.env.NEXTAUTH_SECRET\n    });\n}\n/**\r\n * Higher-order function that creates an API handler that requires authentication\r\n * @param {Function} handler - The API handler to protect\r\n * @returns {Function} - The protected API handler\r\n */ function withAuth(handler) {\n    return async (req, res)=>{\n        const session = await getAuthSession(req);\n        if (!session) {\n            return res.status(401).json({\n                error: \"Unauthorized\"\n            });\n        }\n        // Add the session to the request object\n        req.session = session;\n        // Also add a user property for compatibility\n        req.user = {\n            id: session.sub || session.id,\n            name: session.name,\n            email: session.email\n        };\n        // Call the original handler\n        return handler(req, res);\n    };\n}\n/**\r\n * Higher-order function that optionally requires authentication for certain methods\r\n * @param {Function} handler - The API handler \r\n * @param {Array} protectedMethods - HTTP methods that require authentication (e.g., ['POST', 'PUT', 'DELETE'])\r\n * @returns {Function} - The conditionally protected API handler\r\n */ function withAuthForMethods(handler, protectedMethods = [\n    'POST',\n    'PUT',\n    'DELETE'\n]) {\n    return async (req, res)=>{\n        // Check if the current method requires authentication\n        if (protectedMethods.includes(req.method)) {\n            const session = await getAuthSession(req);\n            if (!session) {\n                return res.status(401).json({\n                    error: \"Unauthorized\"\n                });\n            }\n            // Add the session to the request object\n            req.session = session;\n            // Also add a user property for compatibility\n            req.user = {\n                id: session.sub || session.id,\n                name: session.name,\n                email: session.email\n            };\n        }\n        // Call the original handler\n        return handler(req, res);\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uL2xpYi9hdXRoLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXlDO0FBRXpDOzs7O0NBSUMsR0FDTSxlQUFlQyxlQUFlQyxHQUFHO0lBQ3RDLE9BQU8sTUFBTUYsdURBQVFBLENBQUM7UUFBRUU7UUFBS0MsUUFBUUMsUUFBUUMsR0FBRyxDQUFDQyxlQUFlO0lBQUM7QUFDbkU7QUFFQTs7OztDQUlDLEdBQ00sU0FBU0MsU0FBU0MsT0FBTztJQUM5QixPQUFPLE9BQU9OLEtBQUtPO1FBQ2pCLE1BQU1DLFVBQVUsTUFBTVQsZUFBZUM7UUFFckMsSUFBSSxDQUFDUSxTQUFTO1lBQ1osT0FBT0QsSUFBSUUsTUFBTSxDQUFDLEtBQUtDLElBQUksQ0FBQztnQkFBRUMsT0FBTztZQUFlO1FBQ3REO1FBRUEsd0NBQXdDO1FBQ3hDWCxJQUFJUSxPQUFPLEdBQUdBO1FBRWQsNkNBQTZDO1FBQzdDUixJQUFJWSxJQUFJLEdBQUc7WUFDVEMsSUFBSUwsUUFBUU0sR0FBRyxJQUFJTixRQUFRSyxFQUFFO1lBQzdCRSxNQUFNUCxRQUFRTyxJQUFJO1lBQ2xCQyxPQUFPUixRQUFRUSxLQUFLO1FBQ3RCO1FBRUEsNEJBQTRCO1FBQzVCLE9BQU9WLFFBQVFOLEtBQUtPO0lBQ3RCO0FBQ0Y7QUFFQTs7Ozs7Q0FLQyxHQUNNLFNBQVNVLG1CQUFtQlgsT0FBTyxFQUFFWSxtQkFBbUI7SUFBQztJQUFRO0lBQU87Q0FBUztJQUN0RixPQUFPLE9BQU9sQixLQUFLTztRQUNqQixzREFBc0Q7UUFDdEQsSUFBSVcsaUJBQWlCQyxRQUFRLENBQUNuQixJQUFJb0IsTUFBTSxHQUFHO1lBQ3pDLE1BQU1aLFVBQVUsTUFBTVQsZUFBZUM7WUFFckMsSUFBSSxDQUFDUSxTQUFTO2dCQUNaLE9BQU9ELElBQUlFLE1BQU0sQ0FBQyxLQUFLQyxJQUFJLENBQUM7b0JBQUVDLE9BQU87Z0JBQWU7WUFDdEQ7WUFFQSx3Q0FBd0M7WUFDeENYLElBQUlRLE9BQU8sR0FBR0E7WUFFZCw2Q0FBNkM7WUFDN0NSLElBQUlZLElBQUksR0FBRztnQkFDVEMsSUFBSUwsUUFBUU0sR0FBRyxJQUFJTixRQUFRSyxFQUFFO2dCQUM3QkUsTUFBTVAsUUFBUU8sSUFBSTtnQkFDbEJDLE9BQU9SLFFBQVFRLEtBQUs7WUFDdEI7UUFDRjtRQUVBLDRCQUE0QjtRQUM1QixPQUFPVixRQUFRTixLQUFLTztJQUN0QjtBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGJhdWRpXFxPbmVEcml2ZVxcRGVza3RvcFxcUHJvbXB0UHJvXFxQcm9tcHRQcm9cXGxpYlxcYXV0aC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRUb2tlbiB9IGZyb20gXCJuZXh0LWF1dGgvand0XCI7XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdGhlIHJlcXVlc3QgaXMgYXV0aGVudGljYXRlZFxyXG4gKiBAcGFyYW0ge09iamVjdH0gcmVxIC0gVGhlIHJlcXVlc3Qgb2JqZWN0XHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdHxudWxsPn0gLSBUaGUgdXNlciBzZXNzaW9uIG9yIG51bGwgaWYgbm90IGF1dGhlbnRpY2F0ZWRcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBdXRoU2Vzc2lvbihyZXEpIHtcclxuICByZXR1cm4gYXdhaXQgZ2V0VG9rZW4oeyByZXEsIHNlY3JldDogcHJvY2Vzcy5lbnYuTkVYVEFVVEhfU0VDUkVUIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogSGlnaGVyLW9yZGVyIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhbiBBUEkgaGFuZGxlciB0aGF0IHJlcXVpcmVzIGF1dGhlbnRpY2F0aW9uXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgLSBUaGUgQVBJIGhhbmRsZXIgdG8gcHJvdGVjdFxyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IC0gVGhlIHByb3RlY3RlZCBBUEkgaGFuZGxlclxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHdpdGhBdXRoKGhhbmRsZXIpIHtcclxuICByZXR1cm4gYXN5bmMgKHJlcSwgcmVzKSA9PiB7XHJcbiAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgZ2V0QXV0aFNlc3Npb24ocmVxKTtcclxuICAgIFxyXG4gICAgaWYgKCFzZXNzaW9uKSB7XHJcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKDQwMSkuanNvbih7IGVycm9yOiBcIlVuYXV0aG9yaXplZFwiIH0pO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBBZGQgdGhlIHNlc3Npb24gdG8gdGhlIHJlcXVlc3Qgb2JqZWN0XHJcbiAgICByZXEuc2Vzc2lvbiA9IHNlc3Npb247XHJcbiAgICBcclxuICAgIC8vIEFsc28gYWRkIGEgdXNlciBwcm9wZXJ0eSBmb3IgY29tcGF0aWJpbGl0eVxyXG4gICAgcmVxLnVzZXIgPSB7XHJcbiAgICAgIGlkOiBzZXNzaW9uLnN1YiB8fCBzZXNzaW9uLmlkLFxyXG4gICAgICBuYW1lOiBzZXNzaW9uLm5hbWUsXHJcbiAgICAgIGVtYWlsOiBzZXNzaW9uLmVtYWlsXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvLyBDYWxsIHRoZSBvcmlnaW5hbCBoYW5kbGVyXHJcbiAgICByZXR1cm4gaGFuZGxlcihyZXEsIHJlcyk7XHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEhpZ2hlci1vcmRlciBmdW5jdGlvbiB0aGF0IG9wdGlvbmFsbHkgcmVxdWlyZXMgYXV0aGVudGljYXRpb24gZm9yIGNlcnRhaW4gbWV0aG9kc1xyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIC0gVGhlIEFQSSBoYW5kbGVyIFxyXG4gKiBAcGFyYW0ge0FycmF5fSBwcm90ZWN0ZWRNZXRob2RzIC0gSFRUUCBtZXRob2RzIHRoYXQgcmVxdWlyZSBhdXRoZW50aWNhdGlvbiAoZS5nLiwgWydQT1NUJywgJ1BVVCcsICdERUxFVEUnXSlcclxuICogQHJldHVybnMge0Z1bmN0aW9ufSAtIFRoZSBjb25kaXRpb25hbGx5IHByb3RlY3RlZCBBUEkgaGFuZGxlclxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHdpdGhBdXRoRm9yTWV0aG9kcyhoYW5kbGVyLCBwcm90ZWN0ZWRNZXRob2RzID0gWydQT1NUJywgJ1BVVCcsICdERUxFVEUnXSkge1xyXG4gIHJldHVybiBhc3luYyAocmVxLCByZXMpID0+IHtcclxuICAgIC8vIENoZWNrIGlmIHRoZSBjdXJyZW50IG1ldGhvZCByZXF1aXJlcyBhdXRoZW50aWNhdGlvblxyXG4gICAgaWYgKHByb3RlY3RlZE1ldGhvZHMuaW5jbHVkZXMocmVxLm1ldGhvZCkpIHtcclxuICAgICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IGdldEF1dGhTZXNzaW9uKHJlcSk7XHJcbiAgICAgIFxyXG4gICAgICBpZiAoIXNlc3Npb24pIHtcclxuICAgICAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDEpLmpzb24oeyBlcnJvcjogXCJVbmF1dGhvcml6ZWRcIiB9KTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gQWRkIHRoZSBzZXNzaW9uIHRvIHRoZSByZXF1ZXN0IG9iamVjdFxyXG4gICAgICByZXEuc2Vzc2lvbiA9IHNlc3Npb247XHJcbiAgICAgIFxyXG4gICAgICAvLyBBbHNvIGFkZCBhIHVzZXIgcHJvcGVydHkgZm9yIGNvbXBhdGliaWxpdHlcclxuICAgICAgcmVxLnVzZXIgPSB7XHJcbiAgICAgICAgaWQ6IHNlc3Npb24uc3ViIHx8IHNlc3Npb24uaWQsXHJcbiAgICAgICAgbmFtZTogc2Vzc2lvbi5uYW1lLFxyXG4gICAgICAgIGVtYWlsOiBzZXNzaW9uLmVtYWlsXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIENhbGwgdGhlIG9yaWdpbmFsIGhhbmRsZXJcclxuICAgIHJldHVybiBoYW5kbGVyKHJlcSwgcmVzKTtcclxuICB9O1xyXG59Il0sIm5hbWVzIjpbImdldFRva2VuIiwiZ2V0QXV0aFNlc3Npb24iLCJyZXEiLCJzZWNyZXQiLCJwcm9jZXNzIiwiZW52IiwiTkVYVEFVVEhfU0VDUkVUIiwid2l0aEF1dGgiLCJoYW5kbGVyIiwicmVzIiwic2Vzc2lvbiIsInN0YXR1cyIsImpzb24iLCJlcnJvciIsInVzZXIiLCJpZCIsInN1YiIsIm5hbWUiLCJlbWFpbCIsIndpdGhBdXRoRm9yTWV0aG9kcyIsInByb3RlY3RlZE1ldGhvZHMiLCJpbmNsdWRlcyIsIm1ldGhvZCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api-node)/./lib/auth.js\n");

/***/ }),

/***/ "(api-node)/./lib/db.js":
/*!*******************!*\
  !*** ./lib/db.js ***!
  \*******************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addPromptToCollection: () => (/* binding */ addPromptToCollection),\n/* harmony export */   addTeamMember: () => (/* binding */ addTeamMember),\n/* harmony export */   createCollection: () => (/* binding */ createCollection),\n/* harmony export */   createComment: () => (/* binding */ createComment),\n/* harmony export */   createPrompt: () => (/* binding */ createPrompt),\n/* harmony export */   createTeam: () => (/* binding */ createTeam),\n/* harmony export */   createUser: () => (/* binding */ createUser),\n/* harmony export */   deleteCollection: () => (/* binding */ deleteCollection),\n/* harmony export */   deleteComment: () => (/* binding */ deleteComment),\n/* harmony export */   deletePrompt: () => (/* binding */ deletePrompt),\n/* harmony export */   deleteTeam: () => (/* binding */ deleteTeam),\n/* harmony export */   deleteUser: () => (/* binding */ deleteUser),\n/* harmony export */   getAllCollections: () => (/* binding */ getAllCollections),\n/* harmony export */   getAllPrompts: () => (/* binding */ getAllPrompts),\n/* harmony export */   getAllUsers: () => (/* binding */ getAllUsers),\n/* harmony export */   getCollectionById: () => (/* binding */ getCollectionById),\n/* harmony export */   getCommentsByPromptId: () => (/* binding */ getCommentsByPromptId),\n/* harmony export */   getPromptById: () => (/* binding */ getPromptById),\n/* harmony export */   getTeamById: () => (/* binding */ getTeamById),\n/* harmony export */   getTeamsByUserId: () => (/* binding */ getTeamsByUserId),\n/* harmony export */   getUserByEmail: () => (/* binding */ getUserByEmail),\n/* harmony export */   getUserById: () => (/* binding */ getUserById),\n/* harmony export */   removePromptFromCollection: () => (/* binding */ removePromptFromCollection),\n/* harmony export */   removeTeamMember: () => (/* binding */ removeTeamMember),\n/* harmony export */   updateCollection: () => (/* binding */ updateCollection),\n/* harmony export */   updateComment: () => (/* binding */ updateComment),\n/* harmony export */   updatePrompt: () => (/* binding */ updatePrompt),\n/* harmony export */   updateTeam: () => (/* binding */ updateTeam),\n/* harmony export */   updateUser: () => (/* binding */ updateUser)\n/* harmony export */ });\n/* harmony import */ var _mongodb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mongodb */ \"(api-node)/./lib/mongodb.js\");\n/* harmony import */ var mongodb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mongodb */ \"mongodb\");\n/* harmony import */ var mongodb__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(mongodb__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _auth_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./auth-utils */ \"(api-node)/./lib/auth-utils.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_auth_utils__WEBPACK_IMPORTED_MODULE_2__]);\n_auth_utils__WEBPACK_IMPORTED_MODULE_2__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n // Assuming auth-utils handles password hashing\n/**\r\n * Helper function to get the database and collections.\r\n */ async function getCollections() {\n    const { db } = await (0,_mongodb__WEBPACK_IMPORTED_MODULE_0__.connectToDatabase)();\n    return {\n        users: db.collection('users'),\n        prompts: db.collection('prompts'),\n        collections: db.collection('collections'),\n        teams: db.collection('teams'),\n        comments: db.collection('comments')\n    };\n}\n/**\r\n * Helper function to convert string ID to ObjectId.\r\n * Returns null if the ID is invalid.\r\n */ function toObjectId(id) {\n    if (!id || !mongodb__WEBPACK_IMPORTED_MODULE_1__.ObjectId.isValid(id)) {\n        return null;\n    }\n    try {\n        return new mongodb__WEBPACK_IMPORTED_MODULE_1__.ObjectId(id);\n    } catch (error) {\n        // Handle potential errors during ObjectId creation if needed\n        console.error(\"Error creating ObjectId:\", error);\n        return null;\n    }\n}\n// --- Prompt Functions ---\nconst getAllPrompts = async (filter = {}, options = {})=>{\n    try {\n        const { prompts } = await getCollections();\n        const cursor = prompts.find(filter);\n        // Add sorting if specified in options\n        if (options.sort) {\n            cursor.sort(options.sort);\n        } else {\n            cursor.sort({\n                createdAt: -1\n            }); // Default sort: newest first\n        }\n        // Add limit if specified\n        if (options.limit) {\n            cursor.limit(options.limit);\n        }\n        // Add skip for pagination if specified\n        if (options.skip) {\n            cursor.skip(options.skip);\n        }\n        const allPrompts = await cursor.toArray();\n        return allPrompts;\n    } catch (error) {\n        console.error(\"Error fetching all prompts:\", error);\n        throw new Error(\"Database error while fetching prompts.\");\n    }\n};\nconst getPromptById = async (id)=>{\n    const objectId = toObjectId(id);\n    if (!objectId) return null;\n    try {\n        const { prompts } = await getCollections();\n        const prompt = await prompts.findOne({\n            _id: objectId\n        });\n        return prompt;\n    } catch (error) {\n        console.error(\"Error fetching prompt by ID:\", error);\n        throw new Error(\"Database error while fetching prompt.\");\n    }\n};\nconst createPrompt = async (promptData)=>{\n    try {\n        const { prompts } = await getCollections();\n        const now = new Date();\n        const newPrompt = {\n            title: promptData.title,\n            content: promptData.content,\n            description: promptData.description || '',\n            tags: promptData.tags || [],\n            aiPlatform: promptData.aiPlatform || 'ChatGPT',\n            rating: promptData.rating || 0,\n            usageCount: promptData.usageCount || 0,\n            successRate: promptData.successRate || 0,\n            visibility: promptData.visibility || 'private',\n            userId: promptData.userId,\n            createdBy: promptData.createdBy,\n            teamId: promptData.teamId ? toObjectId(promptData.teamId) : null,\n            createdAt: now,\n            updatedAt: now\n        };\n        const result = await prompts.insertOne(newPrompt);\n        return {\n            ...newPrompt,\n            _id: result.insertedId\n        };\n    } catch (error) {\n        console.error(\"Error creating prompt:\", error);\n        throw new Error(\"Database error while creating prompt.\");\n    }\n};\nconst updatePrompt = async (id, promptData)=>{\n    const objectId = toObjectId(id);\n    if (!objectId) return null;\n    try {\n        const { prompts } = await getCollections();\n        const updateDoc = {\n            $set: {}\n        };\n        // Add fields to update only if they are provided\n        for (const key of [\n            'title',\n            'content',\n            'description',\n            'tags',\n            'aiPlatform',\n            'rating',\n            'usageCount',\n            'successRate',\n            'visibility',\n            'createdBy'\n        ]){\n            if (promptData[key] !== undefined) {\n                updateDoc.$set[key] = promptData[key];\n            }\n        }\n        // Handle teamId separately - allow setting to null or a valid ObjectId\n        if (promptData.teamId !== undefined) {\n            updateDoc.$set.teamId = promptData.teamId ? toObjectId(promptData.teamId) : null;\n        }\n        // Don't update userId or createdAt\n        updateDoc.$set.updatedAt = new Date();\n        if (Object.keys(updateDoc.$set).length === 1) {\n            // Maybe skip update if only timestamp changes?\n            return prompts.findOne({\n                _id: objectId\n            }); // Return current doc\n        }\n        const result = await prompts.updateOne({\n            _id: objectId\n        }, updateDoc);\n        if (result.matchedCount === 0) {\n            return null; // Prompt not found\n        }\n        const updatedPrompt = await prompts.findOne({\n            _id: objectId\n        });\n        return updatedPrompt;\n    } catch (error) {\n        console.error(\"Error updating prompt:\", error);\n        throw new Error(\"Database error while updating prompt.\");\n    }\n};\nconst deletePrompt = async (id)=>{\n    const objectId = toObjectId(id);\n    if (!objectId) return false;\n    try {\n        const { prompts } = await getCollections();\n        // TODO: Consider deleting associated comments or handling dependencies\n        const result = await prompts.deleteOne({\n            _id: objectId\n        });\n        return result.deletedCount > 0;\n    } catch (error) {\n        console.error(\"Error deleting prompt:\", error);\n        throw new Error(\"Database error while deleting prompt.\");\n    }\n};\n// TODO: Implement searchPrompts using MongoDB's text search or complex filtering\n// export const searchPrompts = async (query, options = {}) => { ... };\n// --- Collection Functions ---\nconst getAllCollections = async (filter = {}, options = {})=>{\n    try {\n        const { collections } = await getCollections();\n        const cursor = collections.find(filter);\n        if (options.sort) cursor.sort(options.sort);\n        if (options.limit) cursor.limit(options.limit);\n        if (options.skip) cursor.skip(options.skip);\n        const allCollections = await cursor.toArray();\n        return allCollections;\n    } catch (error) {\n        console.error(\"Error fetching all collections:\", error);\n        throw new Error(\"Database error while fetching collections.\");\n    }\n};\nconst getCollectionById = async (id)=>{\n    const objectId = toObjectId(id);\n    if (!objectId) return null;\n    try {\n        const { collections } = await getCollections();\n        // Optionally use aggregation to populate prompts if needed immediately\n        const collection = await collections.findOne({\n            _id: objectId\n        });\n        return collection;\n    } catch (error) {\n        console.error(\"Error fetching collection by ID:\", error);\n        throw new Error(\"Database error while fetching collection.\");\n    }\n};\nconst createCollection = async (collectionData)=>{\n    try {\n        const { collections } = await getCollections();\n        const now = new Date();\n        const newCollection = {\n            name: collectionData.name,\n            description: collectionData.description || '',\n            userId: collectionData.userId,\n            prompts: [],\n            createdAt: now,\n            updatedAt: now\n        };\n        const result = await collections.insertOne(newCollection);\n        return {\n            ...newCollection,\n            _id: result.insertedId\n        };\n    } catch (error) {\n        console.error(\"Error creating collection:\", error);\n        throw new Error(\"Database error while creating collection.\");\n    }\n};\nconst updateCollection = async (id, collectionData)=>{\n    const objectId = toObjectId(id);\n    if (!objectId) return null;\n    try {\n        const { collections } = await getCollections();\n        const updateDoc = {\n            $set: {}\n        };\n        if (collectionData.name !== undefined) updateDoc.$set.name = collectionData.name;\n        if (collectionData.description !== undefined) updateDoc.$set.description = collectionData.description;\n        // Note: Managing the 'prompts' array (add/remove) typically done via separate functions\n        updateDoc.$set.updatedAt = new Date();\n        if (Object.keys(updateDoc.$set).length > 1) {\n            const result = await collections.updateOne({\n                _id: objectId\n            }, updateDoc);\n            if (result.matchedCount === 0) return null;\n        }\n        const updatedCollection = await collections.findOne({\n            _id: objectId\n        });\n        return updatedCollection;\n    } catch (error) {\n        console.error(\"Error updating collection:\", error);\n        throw new Error(\"Database error while updating collection.\");\n    }\n};\nconst deleteCollection = async (id)=>{\n    const objectId = toObjectId(id);\n    if (!objectId) return false;\n    try {\n        const { collections } = await getCollections();\n        const result = await collections.deleteOne({\n            _id: objectId\n        });\n        return result.deletedCount > 0;\n    } catch (error) {\n        console.error(\"Error deleting collection:\", error);\n        throw new Error(\"Database error while deleting collection.\");\n    }\n};\nconst addPromptToCollection = async (collectionId, promptId)=>{\n    const collObjectId = toObjectId(collectionId);\n    const promptObjectId = toObjectId(promptId);\n    if (!collObjectId || !promptObjectId) return null;\n    try {\n        const { collections } = await getCollections();\n        // Use $addToSet to add the prompt's ObjectId to the array if not already present\n        const result = await collections.updateOne({\n            _id: collObjectId\n        }, {\n            $addToSet: {\n                prompts: promptObjectId\n            },\n            $set: {\n                updatedAt: new Date()\n            }\n        });\n        if (result.matchedCount === 0) return null; // Collection not found\n        const updatedCollection = await collections.findOne({\n            _id: collObjectId\n        });\n        return updatedCollection;\n    } catch (error) {\n        console.error(\"Error adding prompt to collection:\", error);\n        throw new Error(\"Database error while adding prompt to collection.\");\n    }\n};\nconst removePromptFromCollection = async (collectionId, promptId)=>{\n    const collObjectId = toObjectId(collectionId);\n    const promptObjectId = toObjectId(promptId);\n    if (!collObjectId || !promptObjectId) return null;\n    try {\n        const { collections } = await getCollections();\n        // Use $pull to remove the prompt's ObjectId from the array\n        const result = await collections.updateOne({\n            _id: collObjectId\n        }, {\n            $pull: {\n                prompts: promptObjectId\n            },\n            $set: {\n                updatedAt: new Date()\n            }\n        });\n        if (result.matchedCount === 0) return null; // Collection not found\n        const updatedCollection = await collections.findOne({\n            _id: collObjectId\n        });\n        return updatedCollection;\n    } catch (error) {\n        console.error(\"Error removing prompt from collection:\", error);\n        throw new Error(\"Database error while removing prompt from collection.\");\n    }\n};\n// --- User Functions ---\n// Note: These are basic implementations. Authentication libraries often handle user management.\nconst getAllUsers = async (filter = {}, options = {})=>{\n    try {\n        const { users } = await getCollections();\n        // Exclude password field by default\n        const cursor = users.find(filter, {\n            projection: {\n                password: 0\n            }\n        });\n        if (options.sort) cursor.sort(options.sort);\n        if (options.limit) cursor.limit(options.limit);\n        if (options.skip) cursor.skip(options.skip);\n        const allUsers = await cursor.toArray();\n        return allUsers;\n    } catch (error) {\n        console.error(\"Error fetching all users:\", error);\n        throw new Error(\"Database error while fetching users.\");\n    }\n};\nconst getUserById = async (id)=>{\n    const objectId = toObjectId(id);\n    if (!objectId) return null;\n    try {\n        const { users } = await getCollections();\n        const user = await users.findOne({\n            _id: objectId\n        }, {\n            projection: {\n                password: 0\n            }\n        });\n        return user;\n    } catch (error) {\n        console.error(\"Error fetching user by ID:\", error);\n        throw new Error(\"Database error while fetching user.\");\n    }\n};\nconst getUserByEmail = async (email)=>{\n    if (!email) return null;\n    try {\n        const { users } = await getCollections();\n        // Find user by email, but DO include password for authentication checks\n        const user = await users.findOne({\n            email: email.toLowerCase()\n        });\n        return user;\n    } catch (error) {\n        console.error(\"Error fetching user by email:\", error);\n        throw new Error(\"Database error while fetching user.\");\n    }\n};\nconst createUser = async (userData)=>{\n    if (!userData.email || !userData.password) {\n        throw new Error(\"Email and password are required to create a user.\");\n    }\n    try {\n        const { users } = await getCollections();\n        const now = new Date();\n        // Check if user already exists\n        const existingUser = await users.findOne({\n            email: userData.email.toLowerCase()\n        });\n        if (existingUser) {\n            throw new Error(\"User with this email already exists.\");\n        }\n        // Hash password before storing\n        const hashedPassword = await (0,_auth_utils__WEBPACK_IMPORTED_MODULE_2__.hashPassword)(userData.password);\n        const newUser = {\n            name: userData.name || '',\n            email: userData.email.toLowerCase(),\n            password: hashedPassword,\n            image: userData.image || null,\n            // Add roles or other fields as needed\n            createdAt: now,\n            updatedAt: now\n        };\n        const result = await users.insertOne(newUser);\n        // Return user data without the password hash\n        const { password, ...userWithoutPassword } = newUser;\n        return {\n            ...userWithoutPassword,\n            _id: result.insertedId\n        };\n    } catch (error) {\n        console.error(\"Error creating user:\", error);\n        // Rethrow specific errors or a generic one\n        if (error.message === \"User with this email already exists.\") {\n            throw error;\n        }\n        throw new Error(\"Database error while creating user.\");\n    }\n};\nconst updateUser = async (id, userData)=>{\n    const objectId = toObjectId(id);\n    if (!objectId) return null;\n    try {\n        const { users } = await getCollections();\n        const updateDoc = {\n            $set: {}\n        };\n        if (userData.name !== undefined) updateDoc.$set.name = userData.name;\n        if (userData.image !== undefined) updateDoc.$set.image = userData.image;\n        // Add other updatable fields (e.g., roles)\n        // Handle email change carefully\n        if (userData.email && typeof userData.email === 'string') {\n            const newEmail = userData.email.toLowerCase();\n            const existingUser = await users.findOne({\n                email: newEmail\n            });\n            // Allow update only if email doesn't exist OR belongs to the current user\n            if (existingUser && !existingUser._id.equals(objectId)) {\n                throw new Error(\"Email address is already in use.\");\n            }\n            updateDoc.$set.email = newEmail;\n        }\n        // Do not allow password update through this general function\n        // Create a specific changePassword function if needed\n        updateDoc.$set.updatedAt = new Date();\n        if (Object.keys(updateDoc.$set).length > 1) {\n            const result = await users.updateOne({\n                _id: objectId\n            }, updateDoc);\n            if (result.matchedCount === 0) return null;\n        }\n        const updatedUser = await users.findOne({\n            _id: objectId\n        }, {\n            projection: {\n                password: 0\n            }\n        });\n        return updatedUser;\n    } catch (error) {\n        console.error(\"Error updating user:\", error);\n        if (error.message === \"Email address is already in use.\") {\n            throw error;\n        }\n        throw new Error(\"Database error while updating user.\");\n    }\n};\nconst deleteUser = async (id)=>{\n    const objectId = toObjectId(id);\n    if (!objectId) return false;\n    try {\n        const { users } = await getCollections();\n        // TODO: Handle related data cleanup (e.g., reassign prompts?)\n        const result = await users.deleteOne({\n            _id: objectId\n        });\n        return result.deletedCount > 0;\n    } catch (error) {\n        console.error(\"Error deleting user:\", error);\n        throw new Error(\"Database error while deleting user.\");\n    }\n};\n// --- Team Functions (already refactored) ---\nconst getTeamById = async (id)=>{\n    const objectId = toObjectId(id);\n    if (!objectId) return null; // Invalid ID format\n    try {\n        const { teams } = await getCollections();\n        // Fetch team and potentially populate member details if needed later\n        const team = await teams.findOne({\n            _id: objectId\n        });\n        // Optionally convert member userIds back to string if needed for frontend\n        // if (team && team.members) {\n        //   team.members = team.members.map(member => ({ ...member, userId: member.userId.toString() }));\n        // }\n        // Convert main _id to string\n        // if (team) team._id = team._id.toString();\n        return team; // Returns the team document or null if not found\n    } catch (error) {\n        console.error(\"Error fetching team by ID:\", error);\n        throw new Error(\"Database error while fetching team.\");\n    }\n};\nconst getTeamsByUserId = async (userId)=>{\n    // Ensure userId is treated as a string for matching unless it's clearly an ObjectId\n    const userIdString = userId.toString();\n    const userObjectId = toObjectId(userId); // Attempt conversion\n    try {\n        const { teams } = await getCollections();\n        // Find teams where the user is the owner (userId field)\n        // OR the user is in the members array (assuming member.userId is stored as string)\n        const query = {\n            'members.userId': userIdString\n        };\n        // If the original userId was *also* the ownerId field, add that check\n        // This depends on how owner `userId` is stored (string vs ObjectId)\n        // Let's assume owner `userId` might match the string ID from session\n        const ownerQuery = {\n            userId: userIdString\n        };\n        // Combine queries\n        const finalQuery = {\n            $or: [\n                query,\n                ownerQuery\n            ]\n        };\n        // If the userId *was* a valid ObjectId, also check for ObjectId matches \n        // (in case some IDs are stored as ObjectIds)\n        if (userObjectId) {\n            finalQuery.$or.push({\n                'members.userId': userObjectId\n            });\n            finalQuery.$or.push({\n                userId: userObjectId\n            });\n        }\n        const userTeams = await teams.find(finalQuery).toArray();\n        return userTeams;\n    } catch (error) {\n        console.error(\"Error fetching teams by user ID:\", error);\n        throw new Error(\"Database error while fetching user's teams.\");\n    }\n};\nconst createTeam = async (teamData)=>{\n    try {\n        const { teams, users } = await getCollections();\n        const now = new Date();\n        const ownerUserId = teamData.userId; // Assume this is the string ID from session\n        // Fetch owner's name\n        let ownerName = 'Owner'; // Default\n        const ownerUser = await users.findOne({\n            _id: toObjectId(ownerUserId)\n        }, {\n            projection: {\n                name: 1\n            }\n        });\n        if (ownerUser && ownerUser.name) {\n            ownerName = ownerUser.name;\n        }\n        const newTeam = {\n            name: teamData.name,\n            description: teamData.description || '',\n            userId: ownerUserId,\n            members: [],\n            createdAt: now,\n            updatedAt: now\n        };\n        // Add creator as the owner\n        newTeam.members.push({\n            userId: ownerUserId,\n            role: 'owner',\n            joinedAt: now,\n            name: ownerName // Add owner's name\n        });\n        const result = await teams.insertOne(newTeam);\n        return {\n            ...newTeam,\n            _id: result.insertedId\n        };\n    } catch (error) {\n        console.error(\"Error creating team:\", error);\n        throw new Error(\"Database error while creating team.\");\n    }\n};\nconst updateTeam = async (id, teamData)=>{\n    const objectId = toObjectId(id);\n    if (!objectId) return null;\n    try {\n        const { teams } = await getCollections();\n        const updateDoc = {\n            $set: {}\n        };\n        if (teamData.name !== undefined) updateDoc.$set.name = teamData.name;\n        if (teamData.description !== undefined) updateDoc.$set.description = teamData.description;\n        updateDoc.$set.updatedAt = new Date();\n        if (Object.keys(updateDoc.$set).length > 1) {\n            const result = await teams.updateOne({\n                _id: objectId\n            }, updateDoc);\n            if (result.matchedCount === 0) return null;\n        }\n        const updatedTeam = await teams.findOne({\n            _id: objectId\n        });\n        return updatedTeam;\n    } catch (error) {\n        console.error(\"Error updating team:\", error);\n        throw new Error(\"Database error while updating team.\");\n    }\n};\nconst deleteTeam = async (id)=>{\n    const objectId = toObjectId(id);\n    if (!objectId) return false;\n    try {\n        const { teams } = await getCollections();\n        // TODO: Handle related data cleanup (e.g., prompts belonging to team?)\n        const result = await teams.deleteOne({\n            _id: objectId\n        });\n        return result.deletedCount > 0;\n    } catch (error) {\n        console.error(\"Error deleting team:\", error);\n        throw new Error(\"Database error while deleting team.\");\n    }\n};\nconst addTeamMember = async (teamId, memberData)=>{\n    const teamObjectId = toObjectId(teamId);\n    if (!teamObjectId) return null;\n    if (!memberData || !memberData.userId) throw new Error(\"Member user ID is required.\");\n    const memberUserId = memberData.userId; // Assume string ID from request\n    try {\n        const { teams, users } = await getCollections();\n        const now = new Date();\n        // Fetch member's name\n        let memberName = 'Member'; // Default\n        const memberUser = await users.findOne({\n            _id: toObjectId(memberUserId)\n        }, {\n            projection: {\n                name: 1\n            }\n        });\n        if (memberUser && memberUser.name) {\n            memberName = memberUser.name;\n        }\n        const memberRecord = {\n            userId: memberUserId,\n            role: memberData.role || 'member',\n            joinedAt: now,\n            name: memberName // Add member's name\n        };\n        // Check if user is already a member (using the string ID)\n        const team = await teams.findOne({\n            _id: teamObjectId,\n            'members.userId': memberUserId\n        });\n        if (team) {\n            console.log(\"User is already a member of this team.\");\n            return team; // Already a member\n        }\n        // Use $addToSet (or $push if duplicates are impossible/undesired)\n        const result = await teams.updateOne({\n            _id: teamObjectId\n        }, {\n            $push: {\n                members: memberRecord\n            },\n            $set: {\n                updatedAt: now\n            }\n        });\n        if (result.matchedCount === 0) return null;\n        const updatedTeam = await teams.findOne({\n            _id: teamObjectId\n        });\n        return updatedTeam;\n    } catch (error) {\n        console.error(\"Error adding team member:\", error);\n        throw new Error(\"Database error while adding team member.\");\n    }\n};\nconst removeTeamMember = async (teamId, userIdToRemove)=>{\n    const teamObjectId = toObjectId(teamId);\n    if (!teamObjectId) return null;\n    if (!userIdToRemove) throw new Error(\"User ID to remove is required.\");\n    const memberUserIdString = userIdToRemove.toString();\n    try {\n        const { teams } = await getCollections();\n        const now = new Date();\n        // Find the team first to check if the user being removed is the owner\n        const team = await teams.findOne({\n            _id: teamObjectId\n        });\n        if (!team) return null; // Team not found\n        const memberToRemove = team.members.find((m)=>m.userId === memberUserIdString);\n        if (!memberToRemove) {\n            // console.log(\"Member not found in team.\");\n            return team; // Member not found, return current team state\n        }\n        // Prevent removing the owner\n        if (memberToRemove.role === 'owner') {\n            throw new Error(\"Cannot remove the team owner.\");\n        }\n        // Use $pull to remove the member by userId (string match)\n        const result = await teams.updateOne({\n            _id: teamObjectId\n        }, {\n            $pull: {\n                members: {\n                    userId: memberUserIdString\n                }\n            },\n            $set: {\n                updatedAt: now\n            }\n        });\n        if (result.modifiedCount === 0) {\n            // Should not happen if member was found, but handle gracefully\n            console.log(\"Pull operation did not modify the document.\");\n        }\n        const updatedTeam = await teams.findOne({\n            _id: teamObjectId\n        });\n        return updatedTeam;\n    } catch (error) {\n        console.error(\"Error removing team member:\", error);\n        if (error.message === \"Cannot remove the team owner.\") {\n            throw error;\n        }\n        throw new Error(\"Database error while removing team member.\");\n    }\n};\n// TODO: Implement updateTeamMember role if needed\n// --- Comment Functions ---\nconst getCommentsByPromptId = async (promptId)=>{\n    const promptObjectId = toObjectId(promptId);\n    if (!promptObjectId) return [];\n    try {\n        const { comments } = await getCollections();\n        // Fetch comments and sort by creation date (newest first)\n        const promptComments = await comments.find({\n            promptId: promptObjectId\n        }).sort({\n            createdAt: -1\n        }).toArray();\n        return promptComments;\n    } catch (error) {\n        console.error(\"Error fetching comments by prompt ID:\", error);\n        throw new Error(\"Database error while fetching comments.\");\n    }\n};\nconst createComment = async (commentData)=>{\n    if (!commentData.promptId || !commentData.userId || !commentData.content) {\n        throw new Error(\"Prompt ID, User ID, and content are required for comments.\");\n    }\n    const promptObjectId = toObjectId(commentData.promptId);\n    // Assuming userId is passed as string from session\n    const userIdString = commentData.userId.toString();\n    if (!promptObjectId) {\n        throw new Error(\"Invalid Prompt ID format for comment.\");\n    }\n    try {\n        const { comments, users } = await getCollections();\n        const now = new Date();\n        // Fetch commenter's name\n        let createdByName = 'User'; // Default\n        const commenterUser = await users.findOne({\n            _id: toObjectId(userIdString)\n        }, {\n            projection: {\n                name: 1\n            }\n        });\n        if (commenterUser && commenterUser.name) {\n            createdByName = commenterUser.name;\n        }\n        const newComment = {\n            promptId: promptObjectId,\n            userId: userIdString,\n            content: commentData.content,\n            createdBy: createdByName,\n            createdAt: now,\n            updatedAt: now\n        };\n        const result = await comments.insertOne(newComment);\n        return {\n            ...newComment,\n            _id: result.insertedId\n        };\n    } catch (error) {\n        console.error(\"Error creating comment:\", error);\n        throw new Error(\"Database error while creating comment.\");\n    }\n};\nconst updateComment = async (id, commentData)=>{\n    const objectId = toObjectId(id);\n    if (!objectId) return null;\n    if (!commentData.content) {\n        throw new Error(\"Comment content is required for update.\");\n    }\n    try {\n        const { comments } = await getCollections();\n        const updateDoc = {\n            $set: {\n                content: commentData.content,\n                updatedAt: new Date()\n            }\n        };\n        const result = await comments.updateOne({\n            _id: objectId\n        }, updateDoc);\n        if (result.matchedCount === 0) return null;\n        const updatedComment = await comments.findOne({\n            _id: objectId\n        });\n        return updatedComment;\n    } catch (error) {\n        console.error(\"Error updating comment:\", error);\n        throw new Error(\"Database error while updating comment.\");\n    }\n};\nconst deleteComment = async (id)=>{\n    const objectId = toObjectId(id);\n    if (!objectId) return false;\n    try {\n        const { comments } = await getCollections();\n        const result = await comments.deleteOne({\n            _id: objectId\n        });\n        return result.deletedCount > 0;\n    } catch (error) {\n        console.error(\"Error deleting comment:\", error);\n        throw new Error(\"Database error while deleting comment.\");\n    }\n}; // Remove the old in-memory data and initialization logic\n /*\r\nlet prompts = [];\r\nlet collections = [];\r\nlet users = [];\r\nlet teams = [];\r\nlet comments = [];\r\nlet promptIdCounter = 1;\r\nlet collectionIdCounter = 1;\r\nlet userIdCounter = 1;\r\nlet teamIdCounter = 1;\r\nlet commentIdCounter = 1;\r\n\r\n// All old functions like:\r\nexport const getAllPrompts = () => { ... };\r\n// ... etc.\r\n\r\n// Initialize with some sample data - in real app, this would be loaded from database\r\nexport const initializeDb = async () => { ... };\r\n\r\n// Call initialize when imported\r\n(async () => { ... })();\r\n*/ \n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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UztRQUM5RCxPQUFPOEg7SUFDVCxFQUFFLE9BQU83SSxPQUFPO1FBQ2RDLFFBQVFELEtBQUssQ0FBQywyQkFBMkJBO1FBQ3pDLE1BQU0sSUFBSWEsTUFBTTtJQUNsQjtBQUNGLEVBQUU7QUFFSyxNQUFNaUksZ0JBQWdCLE9BQU9oSjtJQUNsQyxNQUFNaUIsV0FBV2xCLFdBQVdDO0lBQzVCLElBQUksQ0FBQ2lCLFVBQVUsT0FBTztJQUN0QixJQUFJO1FBQ0YsTUFBTSxFQUFFbkIsUUFBUSxFQUFFLEdBQUcsTUFBTVA7UUFDM0IsTUFBTWdELFNBQVMsTUFBTXpDLFNBQVN3RCxTQUFTLENBQUM7WUFBRWxDLEtBQUtIO1FBQVM7UUFDeEQsT0FBT3NCLE9BQU9nQixZQUFZLEdBQUc7SUFDL0IsRUFBRSxPQUFPckQsT0FBTztRQUNkQyxRQUFRRCxLQUFLLENBQUMsMkJBQTJCQTtRQUN6QyxNQUFNLElBQUlhLE1BQU07SUFDbEI7QUFDRixFQUFFLENBRUYseURBQXlEO0NBQ3pEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQkEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcYmF1ZGlcXE9uZURyaXZlXFxEZXNrdG9wXFxQcm9tcHRQcm9cXFByb21wdFByb1xcbGliXFxkYi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb25uZWN0VG9EYXRhYmFzZSB9IGZyb20gJy4vbW9uZ29kYic7XHJcbmltcG9ydCB7IE9iamVjdElkIH0gZnJvbSAnbW9uZ29kYic7XHJcbmltcG9ydCB7IGhhc2hQYXNzd29yZCB9IGZyb20gJy4vYXV0aC11dGlscyc7IC8vIEFzc3VtaW5nIGF1dGgtdXRpbHMgaGFuZGxlcyBwYXNzd29yZCBoYXNoaW5nXHJcblxyXG4vKipcclxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgZGF0YWJhc2UgYW5kIGNvbGxlY3Rpb25zLlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZ2V0Q29sbGVjdGlvbnMoKSB7XHJcbiAgY29uc3QgeyBkYiB9ID0gYXdhaXQgY29ubmVjdFRvRGF0YWJhc2UoKTtcclxuICByZXR1cm4ge1xyXG4gICAgdXNlcnM6IGRiLmNvbGxlY3Rpb24oJ3VzZXJzJyksXHJcbiAgICBwcm9tcHRzOiBkYi5jb2xsZWN0aW9uKCdwcm9tcHRzJyksXHJcbiAgICBjb2xsZWN0aW9uczogZGIuY29sbGVjdGlvbignY29sbGVjdGlvbnMnKSxcclxuICAgIHRlYW1zOiBkYi5jb2xsZWN0aW9uKCd0ZWFtcycpLFxyXG4gICAgY29tbWVudHM6IGRiLmNvbGxlY3Rpb24oJ2NvbW1lbnRzJyksXHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBjb252ZXJ0IHN0cmluZyBJRCB0byBPYmplY3RJZC5cclxuICogUmV0dXJucyBudWxsIGlmIHRoZSBJRCBpcyBpbnZhbGlkLlxyXG4gKi9cclxuZnVuY3Rpb24gdG9PYmplY3RJZChpZCkge1xyXG4gIGlmICghaWQgfHwgIU9iamVjdElkLmlzVmFsaWQoaWQpKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbiAgdHJ5IHtcclxuICAgIHJldHVybiBuZXcgT2JqZWN0SWQoaWQpO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAvLyBIYW5kbGUgcG90ZW50aWFsIGVycm9ycyBkdXJpbmcgT2JqZWN0SWQgY3JlYXRpb24gaWYgbmVlZGVkXHJcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY3JlYXRpbmcgT2JqZWN0SWQ6XCIsIGVycm9yKTtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuLy8gLS0tIFByb21wdCBGdW5jdGlvbnMgLS0tXHJcblxyXG5leHBvcnQgY29uc3QgZ2V0QWxsUHJvbXB0cyA9IGFzeW5jIChmaWx0ZXIgPSB7fSwgb3B0aW9ucyA9IHt9KSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHsgcHJvbXB0cyB9ID0gYXdhaXQgZ2V0Q29sbGVjdGlvbnMoKTtcclxuICAgIGNvbnN0IGN1cnNvciA9IHByb21wdHMuZmluZChmaWx0ZXIpO1xyXG4gICAgXHJcbiAgICAvLyBBZGQgc29ydGluZyBpZiBzcGVjaWZpZWQgaW4gb3B0aW9uc1xyXG4gICAgaWYgKG9wdGlvbnMuc29ydCkge1xyXG4gICAgICBjdXJzb3Iuc29ydChvcHRpb25zLnNvcnQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjdXJzb3Iuc29ydCh7IGNyZWF0ZWRBdDogLTEgfSk7IC8vIERlZmF1bHQgc29ydDogbmV3ZXN0IGZpcnN0XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQWRkIGxpbWl0IGlmIHNwZWNpZmllZFxyXG4gICAgaWYgKG9wdGlvbnMubGltaXQpIHtcclxuICAgICAgY3Vyc29yLmxpbWl0KG9wdGlvbnMubGltaXQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFkZCBza2lwIGZvciBwYWdpbmF0aW9uIGlmIHNwZWNpZmllZFxyXG4gICAgaWYgKG9wdGlvbnMuc2tpcCkge1xyXG4gICAgICAgIGN1cnNvci5za2lwKG9wdGlvbnMuc2tpcCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgYWxsUHJvbXB0cyA9IGF3YWl0IGN1cnNvci50b0FycmF5KCk7XHJcbiAgICByZXR1cm4gYWxsUHJvbXB0cztcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIGFsbCBwcm9tcHRzOlwiLCBlcnJvcik7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhYmFzZSBlcnJvciB3aGlsZSBmZXRjaGluZyBwcm9tcHRzLlwiKTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0UHJvbXB0QnlJZCA9IGFzeW5jIChpZCkgPT4ge1xyXG4gIGNvbnN0IG9iamVjdElkID0gdG9PYmplY3RJZChpZCk7XHJcbiAgaWYgKCFvYmplY3RJZCkgcmV0dXJuIG51bGw7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHsgcHJvbXB0cyB9ID0gYXdhaXQgZ2V0Q29sbGVjdGlvbnMoKTtcclxuICAgIGNvbnN0IHByb21wdCA9IGF3YWl0IHByb21wdHMuZmluZE9uZSh7IF9pZDogb2JqZWN0SWQgfSk7XHJcbiAgICByZXR1cm4gcHJvbXB0O1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgcHJvbXB0IGJ5IElEOlwiLCBlcnJvcik7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhYmFzZSBlcnJvciB3aGlsZSBmZXRjaGluZyBwcm9tcHQuXCIpO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjcmVhdGVQcm9tcHQgPSBhc3luYyAocHJvbXB0RGF0YSkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB7IHByb21wdHMgfSA9IGF3YWl0IGdldENvbGxlY3Rpb25zKCk7XHJcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xyXG4gICAgY29uc3QgbmV3UHJvbXB0ID0ge1xyXG4gICAgICB0aXRsZTogcHJvbXB0RGF0YS50aXRsZSxcclxuICAgICAgY29udGVudDogcHJvbXB0RGF0YS5jb250ZW50LFxyXG4gICAgICBkZXNjcmlwdGlvbjogcHJvbXB0RGF0YS5kZXNjcmlwdGlvbiB8fCAnJyxcclxuICAgICAgdGFnczogcHJvbXB0RGF0YS50YWdzIHx8IFtdLFxyXG4gICAgICBhaVBsYXRmb3JtOiBwcm9tcHREYXRhLmFpUGxhdGZvcm0gfHwgJ0NoYXRHUFQnLFxyXG4gICAgICByYXRpbmc6IHByb21wdERhdGEucmF0aW5nIHx8IDAsXHJcbiAgICAgIHVzYWdlQ291bnQ6IHByb21wdERhdGEudXNhZ2VDb3VudCB8fCAwLFxyXG4gICAgICBzdWNjZXNzUmF0ZTogcHJvbXB0RGF0YS5zdWNjZXNzUmF0ZSB8fCAwLFxyXG4gICAgICB2aXNpYmlsaXR5OiBwcm9tcHREYXRhLnZpc2liaWxpdHkgfHwgJ3ByaXZhdGUnLFxyXG4gICAgICB1c2VySWQ6IHByb21wdERhdGEudXNlcklkLCAvLyBTaG91bGQgY29tZSBmcm9tIGF1dGhlbnRpY2F0ZWQgc2Vzc2lvblxyXG4gICAgICBjcmVhdGVkQnk6IHByb21wdERhdGEuY3JlYXRlZEJ5LCAvLyBPcHRpb25hbDogU3RvcmUgY3JlYXRvcidzIG5hbWUvaW5mb1xyXG4gICAgICB0ZWFtSWQ6IHByb21wdERhdGEudGVhbUlkID8gdG9PYmplY3RJZChwcm9tcHREYXRhLnRlYW1JZCkgOiBudWxsLCAvLyBDb252ZXJ0IHRlYW1JZCBpZiBwcmVzZW50XHJcbiAgICAgIGNyZWF0ZWRBdDogbm93LFxyXG4gICAgICB1cGRhdGVkQXQ6IG5vdyxcclxuICAgIH07XHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9tcHRzLmluc2VydE9uZShuZXdQcm9tcHQpO1xyXG4gICAgcmV0dXJuIHsgLi4ubmV3UHJvbXB0LCBfaWQ6IHJlc3VsdC5pbnNlcnRlZElkIH07XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjcmVhdGluZyBwcm9tcHQ6XCIsIGVycm9yKTtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIGVycm9yIHdoaWxlIGNyZWF0aW5nIHByb21wdC5cIik7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHVwZGF0ZVByb21wdCA9IGFzeW5jIChpZCwgcHJvbXB0RGF0YSkgPT4ge1xyXG4gIGNvbnN0IG9iamVjdElkID0gdG9PYmplY3RJZChpZCk7XHJcbiAgaWYgKCFvYmplY3RJZCkgcmV0dXJuIG51bGw7XHJcblxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB7IHByb21wdHMgfSA9IGF3YWl0IGdldENvbGxlY3Rpb25zKCk7XHJcbiAgICBjb25zdCB1cGRhdGVEb2MgPSB7ICRzZXQ6IHt9IH07XHJcblxyXG4gICAgLy8gQWRkIGZpZWxkcyB0byB1cGRhdGUgb25seSBpZiB0aGV5IGFyZSBwcm92aWRlZFxyXG4gICAgZm9yIChjb25zdCBrZXkgb2YgWyd0aXRsZScsICdjb250ZW50JywgJ2Rlc2NyaXB0aW9uJywgJ3RhZ3MnLCAnYWlQbGF0Zm9ybScsICdyYXRpbmcnLCAndXNhZ2VDb3VudCcsICdzdWNjZXNzUmF0ZScsICd2aXNpYmlsaXR5JywgJ2NyZWF0ZWRCeSddKSB7XHJcbiAgICAgIGlmIChwcm9tcHREYXRhW2tleV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHVwZGF0ZURvYy4kc2V0W2tleV0gPSBwcm9tcHREYXRhW2tleV07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIEhhbmRsZSB0ZWFtSWQgc2VwYXJhdGVseSAtIGFsbG93IHNldHRpbmcgdG8gbnVsbCBvciBhIHZhbGlkIE9iamVjdElkXHJcbiAgICBpZiAocHJvbXB0RGF0YS50ZWFtSWQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHVwZGF0ZURvYy4kc2V0LnRlYW1JZCA9IHByb21wdERhdGEudGVhbUlkID8gdG9PYmplY3RJZChwcm9tcHREYXRhLnRlYW1JZCkgOiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERvbid0IHVwZGF0ZSB1c2VySWQgb3IgY3JlYXRlZEF0XHJcbiAgICB1cGRhdGVEb2MuJHNldC51cGRhdGVkQXQgPSBuZXcgRGF0ZSgpO1xyXG5cclxuICAgIGlmIChPYmplY3Qua2V5cyh1cGRhdGVEb2MuJHNldCkubGVuZ3RoID09PSAxKSB7IC8vIE9ubHkgdXBkYXRlZEF0XHJcbiAgICAgICAgLy8gTWF5YmUgc2tpcCB1cGRhdGUgaWYgb25seSB0aW1lc3RhbXAgY2hhbmdlcz9cclxuICAgICAgICByZXR1cm4gcHJvbXB0cy5maW5kT25lKHsgX2lkOiBvYmplY3RJZCB9KTsgLy8gUmV0dXJuIGN1cnJlbnQgZG9jXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvbXB0cy51cGRhdGVPbmUoeyBfaWQ6IG9iamVjdElkIH0sIHVwZGF0ZURvYyk7XHJcblxyXG4gICAgaWYgKHJlc3VsdC5tYXRjaGVkQ291bnQgPT09IDApIHtcclxuICAgICAgcmV0dXJuIG51bGw7IC8vIFByb21wdCBub3QgZm91bmRcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB1cGRhdGVkUHJvbXB0ID0gYXdhaXQgcHJvbXB0cy5maW5kT25lKHsgX2lkOiBvYmplY3RJZCB9KTtcclxuICAgIHJldHVybiB1cGRhdGVkUHJvbXB0O1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgdXBkYXRpbmcgcHJvbXB0OlwiLCBlcnJvcik7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhYmFzZSBlcnJvciB3aGlsZSB1cGRhdGluZyBwcm9tcHQuXCIpO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBkZWxldGVQcm9tcHQgPSBhc3luYyAoaWQpID0+IHtcclxuICBjb25zdCBvYmplY3RJZCA9IHRvT2JqZWN0SWQoaWQpO1xyXG4gIGlmICghb2JqZWN0SWQpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHsgcHJvbXB0cyB9ID0gYXdhaXQgZ2V0Q29sbGVjdGlvbnMoKTtcclxuICAgIC8vIFRPRE86IENvbnNpZGVyIGRlbGV0aW5nIGFzc29jaWF0ZWQgY29tbWVudHMgb3IgaGFuZGxpbmcgZGVwZW5kZW5jaWVzXHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9tcHRzLmRlbGV0ZU9uZSh7IF9pZDogb2JqZWN0SWQgfSk7XHJcbiAgICByZXR1cm4gcmVzdWx0LmRlbGV0ZWRDb3VudCA+IDA7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBkZWxldGluZyBwcm9tcHQ6XCIsIGVycm9yKTtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIGVycm9yIHdoaWxlIGRlbGV0aW5nIHByb21wdC5cIik7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gVE9ETzogSW1wbGVtZW50IHNlYXJjaFByb21wdHMgdXNpbmcgTW9uZ29EQidzIHRleHQgc2VhcmNoIG9yIGNvbXBsZXggZmlsdGVyaW5nXHJcbi8vIGV4cG9ydCBjb25zdCBzZWFyY2hQcm9tcHRzID0gYXN5bmMgKHF1ZXJ5LCBvcHRpb25zID0ge30pID0+IHsgLi4uIH07XHJcblxyXG4vLyAtLS0gQ29sbGVjdGlvbiBGdW5jdGlvbnMgLS0tXHJcblxyXG5leHBvcnQgY29uc3QgZ2V0QWxsQ29sbGVjdGlvbnMgPSBhc3luYyAoZmlsdGVyID0ge30sIG9wdGlvbnMgPSB7fSkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB7IGNvbGxlY3Rpb25zIH0gPSBhd2FpdCBnZXRDb2xsZWN0aW9ucygpO1xyXG4gICAgY29uc3QgY3Vyc29yID0gY29sbGVjdGlvbnMuZmluZChmaWx0ZXIpO1xyXG4gICAgaWYgKG9wdGlvbnMuc29ydCkgY3Vyc29yLnNvcnQob3B0aW9ucy5zb3J0KTtcclxuICAgIGlmIChvcHRpb25zLmxpbWl0KSBjdXJzb3IubGltaXQob3B0aW9ucy5saW1pdCk7XHJcbiAgICBpZiAob3B0aW9ucy5za2lwKSBjdXJzb3Iuc2tpcChvcHRpb25zLnNraXApO1xyXG4gICAgY29uc3QgYWxsQ29sbGVjdGlvbnMgPSBhd2FpdCBjdXJzb3IudG9BcnJheSgpO1xyXG4gICAgcmV0dXJuIGFsbENvbGxlY3Rpb25zO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgYWxsIGNvbGxlY3Rpb25zOlwiLCBlcnJvcik7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhYmFzZSBlcnJvciB3aGlsZSBmZXRjaGluZyBjb2xsZWN0aW9ucy5cIik7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldENvbGxlY3Rpb25CeUlkID0gYXN5bmMgKGlkKSA9PiB7XHJcbiAgY29uc3Qgb2JqZWN0SWQgPSB0b09iamVjdElkKGlkKTtcclxuICBpZiAoIW9iamVjdElkKSByZXR1cm4gbnVsbDtcclxuICB0cnkge1xyXG4gICAgY29uc3QgeyBjb2xsZWN0aW9ucyB9ID0gYXdhaXQgZ2V0Q29sbGVjdGlvbnMoKTtcclxuICAgIC8vIE9wdGlvbmFsbHkgdXNlIGFnZ3JlZ2F0aW9uIHRvIHBvcHVsYXRlIHByb21wdHMgaWYgbmVlZGVkIGltbWVkaWF0ZWx5XHJcbiAgICBjb25zdCBjb2xsZWN0aW9uID0gYXdhaXQgY29sbGVjdGlvbnMuZmluZE9uZSh7IF9pZDogb2JqZWN0SWQgfSk7XHJcbiAgICByZXR1cm4gY29sbGVjdGlvbjtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIGNvbGxlY3Rpb24gYnkgSUQ6XCIsIGVycm9yKTtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIGVycm9yIHdoaWxlIGZldGNoaW5nIGNvbGxlY3Rpb24uXCIpO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjcmVhdGVDb2xsZWN0aW9uID0gYXN5bmMgKGNvbGxlY3Rpb25EYXRhKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHsgY29sbGVjdGlvbnMgfSA9IGF3YWl0IGdldENvbGxlY3Rpb25zKCk7XHJcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xyXG4gICAgY29uc3QgbmV3Q29sbGVjdGlvbiA9IHtcclxuICAgICAgbmFtZTogY29sbGVjdGlvbkRhdGEubmFtZSxcclxuICAgICAgZGVzY3JpcHRpb246IGNvbGxlY3Rpb25EYXRhLmRlc2NyaXB0aW9uIHx8ICcnLFxyXG4gICAgICB1c2VySWQ6IGNvbGxlY3Rpb25EYXRhLnVzZXJJZCwgLy8gRnJvbSBzZXNzaW9uXHJcbiAgICAgIHByb21wdHM6IFtdLCAvLyBTdG9yZSBwcm9tcHQgT2JqZWN0SWRzIGhlcmVcclxuICAgICAgY3JlYXRlZEF0OiBub3csXHJcbiAgICAgIHVwZGF0ZWRBdDogbm93LFxyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbGxlY3Rpb25zLmluc2VydE9uZShuZXdDb2xsZWN0aW9uKTtcclxuICAgIHJldHVybiB7IC4uLm5ld0NvbGxlY3Rpb24sIF9pZDogcmVzdWx0Lmluc2VydGVkSWQgfTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGNyZWF0aW5nIGNvbGxlY3Rpb246XCIsIGVycm9yKTtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIGVycm9yIHdoaWxlIGNyZWF0aW5nIGNvbGxlY3Rpb24uXCIpO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCB1cGRhdGVDb2xsZWN0aW9uID0gYXN5bmMgKGlkLCBjb2xsZWN0aW9uRGF0YSkgPT4ge1xyXG4gIGNvbnN0IG9iamVjdElkID0gdG9PYmplY3RJZChpZCk7XHJcbiAgaWYgKCFvYmplY3RJZCkgcmV0dXJuIG51bGw7XHJcblxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB7IGNvbGxlY3Rpb25zIH0gPSBhd2FpdCBnZXRDb2xsZWN0aW9ucygpO1xyXG4gICAgY29uc3QgdXBkYXRlRG9jID0geyAkc2V0OiB7fSB9O1xyXG4gICAgaWYgKGNvbGxlY3Rpb25EYXRhLm5hbWUgIT09IHVuZGVmaW5lZCkgdXBkYXRlRG9jLiRzZXQubmFtZSA9IGNvbGxlY3Rpb25EYXRhLm5hbWU7XHJcbiAgICBpZiAoY29sbGVjdGlvbkRhdGEuZGVzY3JpcHRpb24gIT09IHVuZGVmaW5lZCkgdXBkYXRlRG9jLiRzZXQuZGVzY3JpcHRpb24gPSBjb2xsZWN0aW9uRGF0YS5kZXNjcmlwdGlvbjtcclxuICAgIC8vIE5vdGU6IE1hbmFnaW5nIHRoZSAncHJvbXB0cycgYXJyYXkgKGFkZC9yZW1vdmUpIHR5cGljYWxseSBkb25lIHZpYSBzZXBhcmF0ZSBmdW5jdGlvbnNcclxuICAgIHVwZGF0ZURvYy4kc2V0LnVwZGF0ZWRBdCA9IG5ldyBEYXRlKCk7XHJcblxyXG4gICAgaWYgKE9iamVjdC5rZXlzKHVwZGF0ZURvYy4kc2V0KS5sZW5ndGggPiAxKSB7XHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbGxlY3Rpb25zLnVwZGF0ZU9uZSh7IF9pZDogb2JqZWN0SWQgfSwgdXBkYXRlRG9jKTtcclxuICAgICAgaWYgKHJlc3VsdC5tYXRjaGVkQ291bnQgPT09IDApIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHVwZGF0ZWRDb2xsZWN0aW9uID0gYXdhaXQgY29sbGVjdGlvbnMuZmluZE9uZSh7IF9pZDogb2JqZWN0SWQgfSk7XHJcbiAgICByZXR1cm4gdXBkYXRlZENvbGxlY3Rpb247XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciB1cGRhdGluZyBjb2xsZWN0aW9uOlwiLCBlcnJvcik7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhYmFzZSBlcnJvciB3aGlsZSB1cGRhdGluZyBjb2xsZWN0aW9uLlwiKTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZGVsZXRlQ29sbGVjdGlvbiA9IGFzeW5jIChpZCkgPT4ge1xyXG4gIGNvbnN0IG9iamVjdElkID0gdG9PYmplY3RJZChpZCk7XHJcbiAgaWYgKCFvYmplY3RJZCkgcmV0dXJuIGZhbHNlO1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB7IGNvbGxlY3Rpb25zIH0gPSBhd2FpdCBnZXRDb2xsZWN0aW9ucygpO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29sbGVjdGlvbnMuZGVsZXRlT25lKHsgX2lkOiBvYmplY3RJZCB9KTtcclxuICAgIHJldHVybiByZXN1bHQuZGVsZXRlZENvdW50ID4gMDtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGRlbGV0aW5nIGNvbGxlY3Rpb246XCIsIGVycm9yKTtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIGVycm9yIHdoaWxlIGRlbGV0aW5nIGNvbGxlY3Rpb24uXCIpO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBhZGRQcm9tcHRUb0NvbGxlY3Rpb24gPSBhc3luYyAoY29sbGVjdGlvbklkLCBwcm9tcHRJZCkgPT4ge1xyXG4gIGNvbnN0IGNvbGxPYmplY3RJZCA9IHRvT2JqZWN0SWQoY29sbGVjdGlvbklkKTtcclxuICBjb25zdCBwcm9tcHRPYmplY3RJZCA9IHRvT2JqZWN0SWQocHJvbXB0SWQpO1xyXG4gIGlmICghY29sbE9iamVjdElkIHx8ICFwcm9tcHRPYmplY3RJZCkgcmV0dXJuIG51bGw7XHJcblxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB7IGNvbGxlY3Rpb25zIH0gPSBhd2FpdCBnZXRDb2xsZWN0aW9ucygpO1xyXG4gICAgLy8gVXNlICRhZGRUb1NldCB0byBhZGQgdGhlIHByb21wdCdzIE9iamVjdElkIHRvIHRoZSBhcnJheSBpZiBub3QgYWxyZWFkeSBwcmVzZW50XHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb2xsZWN0aW9ucy51cGRhdGVPbmUoXHJcbiAgICAgIHsgX2lkOiBjb2xsT2JqZWN0SWQgfSxcclxuICAgICAgeyBcclxuICAgICAgICAkYWRkVG9TZXQ6IHsgcHJvbXB0czogcHJvbXB0T2JqZWN0SWQgfSxcclxuICAgICAgICAkc2V0OiB7IHVwZGF0ZWRBdDogbmV3IERhdGUoKSB9XHJcbiAgICAgIH1cclxuICAgICk7XHJcbiAgICBpZiAocmVzdWx0Lm1hdGNoZWRDb3VudCA9PT0gMCkgcmV0dXJuIG51bGw7IC8vIENvbGxlY3Rpb24gbm90IGZvdW5kXHJcbiAgICBcclxuICAgIGNvbnN0IHVwZGF0ZWRDb2xsZWN0aW9uID0gYXdhaXQgY29sbGVjdGlvbnMuZmluZE9uZSh7IF9pZDogY29sbE9iamVjdElkIH0pO1xyXG4gICAgcmV0dXJuIHVwZGF0ZWRDb2xsZWN0aW9uO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgYWRkaW5nIHByb21wdCB0byBjb2xsZWN0aW9uOlwiLCBlcnJvcik7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhYmFzZSBlcnJvciB3aGlsZSBhZGRpbmcgcHJvbXB0IHRvIGNvbGxlY3Rpb24uXCIpO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCByZW1vdmVQcm9tcHRGcm9tQ29sbGVjdGlvbiA9IGFzeW5jIChjb2xsZWN0aW9uSWQsIHByb21wdElkKSA9PiB7XHJcbiAgY29uc3QgY29sbE9iamVjdElkID0gdG9PYmplY3RJZChjb2xsZWN0aW9uSWQpO1xyXG4gIGNvbnN0IHByb21wdE9iamVjdElkID0gdG9PYmplY3RJZChwcm9tcHRJZCk7XHJcbiAgaWYgKCFjb2xsT2JqZWN0SWQgfHwgIXByb21wdE9iamVjdElkKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHsgY29sbGVjdGlvbnMgfSA9IGF3YWl0IGdldENvbGxlY3Rpb25zKCk7XHJcbiAgICAvLyBVc2UgJHB1bGwgdG8gcmVtb3ZlIHRoZSBwcm9tcHQncyBPYmplY3RJZCBmcm9tIHRoZSBhcnJheVxyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29sbGVjdGlvbnMudXBkYXRlT25lKFxyXG4gICAgICB7IF9pZDogY29sbE9iamVjdElkIH0sXHJcbiAgICAgIHsgXHJcbiAgICAgICAgJHB1bGw6IHsgcHJvbXB0czogcHJvbXB0T2JqZWN0SWQgfSxcclxuICAgICAgICAkc2V0OiB7IHVwZGF0ZWRBdDogbmV3IERhdGUoKSB9IFxyXG4gICAgICB9XHJcbiAgICApO1xyXG4gICAgaWYgKHJlc3VsdC5tYXRjaGVkQ291bnQgPT09IDApIHJldHVybiBudWxsOyAvLyBDb2xsZWN0aW9uIG5vdCBmb3VuZFxyXG5cclxuICAgIGNvbnN0IHVwZGF0ZWRDb2xsZWN0aW9uID0gYXdhaXQgY29sbGVjdGlvbnMuZmluZE9uZSh7IF9pZDogY29sbE9iamVjdElkIH0pO1xyXG4gICAgcmV0dXJuIHVwZGF0ZWRDb2xsZWN0aW9uO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcmVtb3ZpbmcgcHJvbXB0IGZyb20gY29sbGVjdGlvbjpcIiwgZXJyb3IpO1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YWJhc2UgZXJyb3Igd2hpbGUgcmVtb3ZpbmcgcHJvbXB0IGZyb20gY29sbGVjdGlvbi5cIik7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gLS0tIFVzZXIgRnVuY3Rpb25zIC0tLVxyXG4vLyBOb3RlOiBUaGVzZSBhcmUgYmFzaWMgaW1wbGVtZW50YXRpb25zLiBBdXRoZW50aWNhdGlvbiBsaWJyYXJpZXMgb2Z0ZW4gaGFuZGxlIHVzZXIgbWFuYWdlbWVudC5cclxuXHJcbmV4cG9ydCBjb25zdCBnZXRBbGxVc2VycyA9IGFzeW5jIChmaWx0ZXIgPSB7fSwgb3B0aW9ucyA9IHt9KSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHsgdXNlcnMgfSA9IGF3YWl0IGdldENvbGxlY3Rpb25zKCk7XHJcbiAgICAvLyBFeGNsdWRlIHBhc3N3b3JkIGZpZWxkIGJ5IGRlZmF1bHRcclxuICAgIGNvbnN0IGN1cnNvciA9IHVzZXJzLmZpbmQoZmlsdGVyLCB7IHByb2plY3Rpb246IHsgcGFzc3dvcmQ6IDAgfSB9KTsgXHJcbiAgICBpZiAob3B0aW9ucy5zb3J0KSBjdXJzb3Iuc29ydChvcHRpb25zLnNvcnQpO1xyXG4gICAgaWYgKG9wdGlvbnMubGltaXQpIGN1cnNvci5saW1pdChvcHRpb25zLmxpbWl0KTtcclxuICAgIGlmIChvcHRpb25zLnNraXApIGN1cnNvci5za2lwKG9wdGlvbnMuc2tpcCk7XHJcbiAgICBjb25zdCBhbGxVc2VycyA9IGF3YWl0IGN1cnNvci50b0FycmF5KCk7XHJcbiAgICByZXR1cm4gYWxsVXNlcnM7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyBhbGwgdXNlcnM6XCIsIGVycm9yKTtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIGVycm9yIHdoaWxlIGZldGNoaW5nIHVzZXJzLlwiKTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0VXNlckJ5SWQgPSBhc3luYyAoaWQpID0+IHtcclxuICBjb25zdCBvYmplY3RJZCA9IHRvT2JqZWN0SWQoaWQpO1xyXG4gIGlmICghb2JqZWN0SWQpIHJldHVybiBudWxsO1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB7IHVzZXJzIH0gPSBhd2FpdCBnZXRDb2xsZWN0aW9ucygpO1xyXG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHVzZXJzLmZpbmRPbmUoeyBfaWQ6IG9iamVjdElkIH0sIHsgcHJvamVjdGlvbjogeyBwYXNzd29yZDogMCB9IH0pO1xyXG4gICAgcmV0dXJuIHVzZXI7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyB1c2VyIGJ5IElEOlwiLCBlcnJvcik7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhYmFzZSBlcnJvciB3aGlsZSBmZXRjaGluZyB1c2VyLlwiKTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0VXNlckJ5RW1haWwgPSBhc3luYyAoZW1haWwpID0+IHtcclxuICBpZiAoIWVtYWlsKSByZXR1cm4gbnVsbDtcclxuICB0cnkge1xyXG4gICAgY29uc3QgeyB1c2VycyB9ID0gYXdhaXQgZ2V0Q29sbGVjdGlvbnMoKTtcclxuICAgIC8vIEZpbmQgdXNlciBieSBlbWFpbCwgYnV0IERPIGluY2x1ZGUgcGFzc3dvcmQgZm9yIGF1dGhlbnRpY2F0aW9uIGNoZWNrc1xyXG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHVzZXJzLmZpbmRPbmUoeyBlbWFpbDogZW1haWwudG9Mb3dlckNhc2UoKSB9KTtcclxuICAgIHJldHVybiB1c2VyOyBcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIHVzZXIgYnkgZW1haWw6XCIsIGVycm9yKTtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIGVycm9yIHdoaWxlIGZldGNoaW5nIHVzZXIuXCIpO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjcmVhdGVVc2VyID0gYXN5bmMgKHVzZXJEYXRhKSA9PiB7XHJcbiAgaWYgKCF1c2VyRGF0YS5lbWFpbCB8fCAhdXNlckRhdGEucGFzc3dvcmQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIkVtYWlsIGFuZCBwYXNzd29yZCBhcmUgcmVxdWlyZWQgdG8gY3JlYXRlIGEgdXNlci5cIik7XHJcbiAgfVxyXG4gIFxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB7IHVzZXJzIH0gPSBhd2FpdCBnZXRDb2xsZWN0aW9ucygpO1xyXG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcclxuICAgIFxyXG4gICAgLy8gQ2hlY2sgaWYgdXNlciBhbHJlYWR5IGV4aXN0c1xyXG4gICAgY29uc3QgZXhpc3RpbmdVc2VyID0gYXdhaXQgdXNlcnMuZmluZE9uZSh7IGVtYWlsOiB1c2VyRGF0YS5lbWFpbC50b0xvd2VyQ2FzZSgpIH0pO1xyXG4gICAgaWYgKGV4aXN0aW5nVXNlcikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVc2VyIHdpdGggdGhpcyBlbWFpbCBhbHJlYWR5IGV4aXN0cy5cIik7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEhhc2ggcGFzc3dvcmQgYmVmb3JlIHN0b3JpbmdcclxuICAgIGNvbnN0IGhhc2hlZFBhc3N3b3JkID0gYXdhaXQgaGFzaFBhc3N3b3JkKHVzZXJEYXRhLnBhc3N3b3JkKTtcclxuICAgIFxyXG4gICAgY29uc3QgbmV3VXNlciA9IHtcclxuICAgICAgbmFtZTogdXNlckRhdGEubmFtZSB8fCAnJyxcclxuICAgICAgZW1haWw6IHVzZXJEYXRhLmVtYWlsLnRvTG93ZXJDYXNlKCksXHJcbiAgICAgIHBhc3N3b3JkOiBoYXNoZWRQYXNzd29yZCxcclxuICAgICAgaW1hZ2U6IHVzZXJEYXRhLmltYWdlIHx8IG51bGwsXHJcbiAgICAgIC8vIEFkZCByb2xlcyBvciBvdGhlciBmaWVsZHMgYXMgbmVlZGVkXHJcbiAgICAgIGNyZWF0ZWRBdDogbm93LFxyXG4gICAgICB1cGRhdGVkQXQ6IG5vdyxcclxuICAgIH07XHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB1c2Vycy5pbnNlcnRPbmUobmV3VXNlcik7XHJcbiAgICAvLyBSZXR1cm4gdXNlciBkYXRhIHdpdGhvdXQgdGhlIHBhc3N3b3JkIGhhc2hcclxuICAgIGNvbnN0IHsgcGFzc3dvcmQsIC4uLnVzZXJXaXRob3V0UGFzc3dvcmQgfSA9IG5ld1VzZXI7XHJcbiAgICByZXR1cm4geyAuLi51c2VyV2l0aG91dFBhc3N3b3JkLCBfaWQ6IHJlc3VsdC5pbnNlcnRlZElkIH07XHJcblxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY3JlYXRpbmcgdXNlcjpcIiwgZXJyb3IpO1xyXG4gICAgLy8gUmV0aHJvdyBzcGVjaWZpYyBlcnJvcnMgb3IgYSBnZW5lcmljIG9uZVxyXG4gICAgaWYgKGVycm9yLm1lc3NhZ2UgPT09IFwiVXNlciB3aXRoIHRoaXMgZW1haWwgYWxyZWFkeSBleGlzdHMuXCIpIHtcclxuICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIGVycm9yIHdoaWxlIGNyZWF0aW5nIHVzZXIuXCIpO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCB1cGRhdGVVc2VyID0gYXN5bmMgKGlkLCB1c2VyRGF0YSkgPT4ge1xyXG4gIGNvbnN0IG9iamVjdElkID0gdG9PYmplY3RJZChpZCk7XHJcbiAgaWYgKCFvYmplY3RJZCkgcmV0dXJuIG51bGw7XHJcblxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB7IHVzZXJzIH0gPSBhd2FpdCBnZXRDb2xsZWN0aW9ucygpO1xyXG4gICAgY29uc3QgdXBkYXRlRG9jID0geyAkc2V0OiB7fSB9O1xyXG5cclxuICAgIGlmICh1c2VyRGF0YS5uYW1lICE9PSB1bmRlZmluZWQpIHVwZGF0ZURvYy4kc2V0Lm5hbWUgPSB1c2VyRGF0YS5uYW1lO1xyXG4gICAgaWYgKHVzZXJEYXRhLmltYWdlICE9PSB1bmRlZmluZWQpIHVwZGF0ZURvYy4kc2V0LmltYWdlID0gdXNlckRhdGEuaW1hZ2U7XHJcbiAgICAvLyBBZGQgb3RoZXIgdXBkYXRhYmxlIGZpZWxkcyAoZS5nLiwgcm9sZXMpXHJcbiAgICBcclxuICAgIC8vIEhhbmRsZSBlbWFpbCBjaGFuZ2UgY2FyZWZ1bGx5XHJcbiAgICBpZiAodXNlckRhdGEuZW1haWwgJiYgdHlwZW9mIHVzZXJEYXRhLmVtYWlsID09PSAnc3RyaW5nJykge1xyXG4gICAgICBjb25zdCBuZXdFbWFpbCA9IHVzZXJEYXRhLmVtYWlsLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgIGNvbnN0IGV4aXN0aW5nVXNlciA9IGF3YWl0IHVzZXJzLmZpbmRPbmUoeyBlbWFpbDogbmV3RW1haWwgfSk7XHJcbiAgICAgIC8vIEFsbG93IHVwZGF0ZSBvbmx5IGlmIGVtYWlsIGRvZXNuJ3QgZXhpc3QgT1IgYmVsb25ncyB0byB0aGUgY3VycmVudCB1c2VyXHJcbiAgICAgIGlmIChleGlzdGluZ1VzZXIgJiYgIWV4aXN0aW5nVXNlci5faWQuZXF1YWxzKG9iamVjdElkKSkge1xyXG4gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbWFpbCBhZGRyZXNzIGlzIGFscmVhZHkgaW4gdXNlLlwiKTtcclxuICAgICAgfVxyXG4gICAgICB1cGRhdGVEb2MuJHNldC5lbWFpbCA9IG5ld0VtYWlsO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBEbyBub3QgYWxsb3cgcGFzc3dvcmQgdXBkYXRlIHRocm91Z2ggdGhpcyBnZW5lcmFsIGZ1bmN0aW9uXHJcbiAgICAvLyBDcmVhdGUgYSBzcGVjaWZpYyBjaGFuZ2VQYXNzd29yZCBmdW5jdGlvbiBpZiBuZWVkZWRcclxuXHJcbiAgICB1cGRhdGVEb2MuJHNldC51cGRhdGVkQXQgPSBuZXcgRGF0ZSgpO1xyXG5cclxuICAgIGlmIChPYmplY3Qua2V5cyh1cGRhdGVEb2MuJHNldCkubGVuZ3RoID4gMSkge1xyXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB1c2Vycy51cGRhdGVPbmUoeyBfaWQ6IG9iamVjdElkIH0sIHVwZGF0ZURvYyk7XHJcbiAgICAgIGlmIChyZXN1bHQubWF0Y2hlZENvdW50ID09PSAwKSByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB1cGRhdGVkVXNlciA9IGF3YWl0IHVzZXJzLmZpbmRPbmUoeyBfaWQ6IG9iamVjdElkIH0sIHsgcHJvamVjdGlvbjogeyBwYXNzd29yZDogMCB9IH0pO1xyXG4gICAgcmV0dXJuIHVwZGF0ZWRVc2VyO1xyXG5cclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIHVwZGF0aW5nIHVzZXI6XCIsIGVycm9yKTtcclxuICAgICBpZiAoZXJyb3IubWVzc2FnZSA9PT0gXCJFbWFpbCBhZGRyZXNzIGlzIGFscmVhZHkgaW4gdXNlLlwiKSB7XHJcbiAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhYmFzZSBlcnJvciB3aGlsZSB1cGRhdGluZyB1c2VyLlwiKTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZGVsZXRlVXNlciA9IGFzeW5jIChpZCkgPT4ge1xyXG4gIGNvbnN0IG9iamVjdElkID0gdG9PYmplY3RJZChpZCk7XHJcbiAgaWYgKCFvYmplY3RJZCkgcmV0dXJuIGZhbHNlO1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB7IHVzZXJzIH0gPSBhd2FpdCBnZXRDb2xsZWN0aW9ucygpO1xyXG4gICAgLy8gVE9ETzogSGFuZGxlIHJlbGF0ZWQgZGF0YSBjbGVhbnVwIChlLmcuLCByZWFzc2lnbiBwcm9tcHRzPylcclxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHVzZXJzLmRlbGV0ZU9uZSh7IF9pZDogb2JqZWN0SWQgfSk7XHJcbiAgICByZXR1cm4gcmVzdWx0LmRlbGV0ZWRDb3VudCA+IDA7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBkZWxldGluZyB1c2VyOlwiLCBlcnJvcik7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhYmFzZSBlcnJvciB3aGlsZSBkZWxldGluZyB1c2VyLlwiKTtcclxuICB9XHJcbn07XHJcblxyXG5cclxuLy8gLS0tIFRlYW0gRnVuY3Rpb25zIChhbHJlYWR5IHJlZmFjdG9yZWQpIC0tLVxyXG5cclxuZXhwb3J0IGNvbnN0IGdldFRlYW1CeUlkID0gYXN5bmMgKGlkKSA9PiB7XHJcbiAgY29uc3Qgb2JqZWN0SWQgPSB0b09iamVjdElkKGlkKTtcclxuICBpZiAoIW9iamVjdElkKSByZXR1cm4gbnVsbDsgLy8gSW52YWxpZCBJRCBmb3JtYXRcclxuICBcclxuICB0cnkge1xyXG4gICAgY29uc3QgeyB0ZWFtcyB9ID0gYXdhaXQgZ2V0Q29sbGVjdGlvbnMoKTtcclxuICAgIC8vIEZldGNoIHRlYW0gYW5kIHBvdGVudGlhbGx5IHBvcHVsYXRlIG1lbWJlciBkZXRhaWxzIGlmIG5lZWRlZCBsYXRlclxyXG4gICAgY29uc3QgdGVhbSA9IGF3YWl0IHRlYW1zLmZpbmRPbmUoeyBfaWQ6IG9iamVjdElkIH0pO1xyXG4gICAgXHJcbiAgICAvLyBPcHRpb25hbGx5IGNvbnZlcnQgbWVtYmVyIHVzZXJJZHMgYmFjayB0byBzdHJpbmcgaWYgbmVlZGVkIGZvciBmcm9udGVuZFxyXG4gICAgLy8gaWYgKHRlYW0gJiYgdGVhbS5tZW1iZXJzKSB7XHJcbiAgICAvLyAgIHRlYW0ubWVtYmVycyA9IHRlYW0ubWVtYmVycy5tYXAobWVtYmVyID0+ICh7IC4uLm1lbWJlciwgdXNlcklkOiBtZW1iZXIudXNlcklkLnRvU3RyaW5nKCkgfSkpO1xyXG4gICAgLy8gfVxyXG4gICAgLy8gQ29udmVydCBtYWluIF9pZCB0byBzdHJpbmdcclxuICAgIC8vIGlmICh0ZWFtKSB0ZWFtLl9pZCA9IHRlYW0uX2lkLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgcmV0dXJuIHRlYW07IC8vIFJldHVybnMgdGhlIHRlYW0gZG9jdW1lbnQgb3IgbnVsbCBpZiBub3QgZm91bmRcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIHRlYW0gYnkgSUQ6XCIsIGVycm9yKTtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIGVycm9yIHdoaWxlIGZldGNoaW5nIHRlYW0uXCIpO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRUZWFtc0J5VXNlcklkID0gYXN5bmMgKHVzZXJJZCkgPT4ge1xyXG4gIC8vIEVuc3VyZSB1c2VySWQgaXMgdHJlYXRlZCBhcyBhIHN0cmluZyBmb3IgbWF0Y2hpbmcgdW5sZXNzIGl0J3MgY2xlYXJseSBhbiBPYmplY3RJZFxyXG4gIGNvbnN0IHVzZXJJZFN0cmluZyA9IHVzZXJJZC50b1N0cmluZygpOyBcclxuICBjb25zdCB1c2VyT2JqZWN0SWQgPSB0b09iamVjdElkKHVzZXJJZCk7IC8vIEF0dGVtcHQgY29udmVyc2lvblxyXG5cclxuICB0cnkge1xyXG4gICAgY29uc3QgeyB0ZWFtcyB9ID0gYXdhaXQgZ2V0Q29sbGVjdGlvbnMoKTtcclxuICAgIC8vIEZpbmQgdGVhbXMgd2hlcmUgdGhlIHVzZXIgaXMgdGhlIG93bmVyICh1c2VySWQgZmllbGQpXHJcbiAgICAvLyBPUiB0aGUgdXNlciBpcyBpbiB0aGUgbWVtYmVycyBhcnJheSAoYXNzdW1pbmcgbWVtYmVyLnVzZXJJZCBpcyBzdG9yZWQgYXMgc3RyaW5nKVxyXG4gICAgY29uc3QgcXVlcnkgPSB7XHJcbiAgICAgICdtZW1iZXJzLnVzZXJJZCc6IHVzZXJJZFN0cmluZ1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBJZiB0aGUgb3JpZ2luYWwgdXNlcklkIHdhcyAqYWxzbyogdGhlIG93bmVySWQgZmllbGQsIGFkZCB0aGF0IGNoZWNrXHJcbiAgICAvLyBUaGlzIGRlcGVuZHMgb24gaG93IG93bmVyIGB1c2VySWRgIGlzIHN0b3JlZCAoc3RyaW5nIHZzIE9iamVjdElkKVxyXG4gICAgLy8gTGV0J3MgYXNzdW1lIG93bmVyIGB1c2VySWRgIG1pZ2h0IG1hdGNoIHRoZSBzdHJpbmcgSUQgZnJvbSBzZXNzaW9uXHJcbiAgICBjb25zdCBvd25lclF1ZXJ5ID0geyB1c2VySWQ6IHVzZXJJZFN0cmluZyB9O1xyXG5cclxuICAgIC8vIENvbWJpbmUgcXVlcmllc1xyXG4gICAgY29uc3QgZmluYWxRdWVyeSA9IHtcclxuICAgICAgJG9yOiBbXHJcbiAgICAgICAgIHF1ZXJ5LFxyXG4gICAgICAgICBvd25lclF1ZXJ5XHJcbiAgICAgICBdXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvLyBJZiB0aGUgdXNlcklkICp3YXMqIGEgdmFsaWQgT2JqZWN0SWQsIGFsc28gY2hlY2sgZm9yIE9iamVjdElkIG1hdGNoZXMgXHJcbiAgICAvLyAoaW4gY2FzZSBzb21lIElEcyBhcmUgc3RvcmVkIGFzIE9iamVjdElkcylcclxuICAgIGlmICh1c2VyT2JqZWN0SWQpIHtcclxuICAgICAgIGZpbmFsUXVlcnkuJG9yLnB1c2goeyAnbWVtYmVycy51c2VySWQnOiB1c2VyT2JqZWN0SWQgfSk7XHJcbiAgICAgICBmaW5hbFF1ZXJ5LiRvci5wdXNoKHsgdXNlcklkOiB1c2VyT2JqZWN0SWQgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdXNlclRlYW1zID0gYXdhaXQgdGVhbXMuZmluZChmaW5hbFF1ZXJ5KS50b0FycmF5KCk7XHJcbiAgICByZXR1cm4gdXNlclRlYW1zO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgdGVhbXMgYnkgdXNlciBJRDpcIiwgZXJyb3IpO1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YWJhc2UgZXJyb3Igd2hpbGUgZmV0Y2hpbmcgdXNlcidzIHRlYW1zLlwiKTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY3JlYXRlVGVhbSA9IGFzeW5jICh0ZWFtRGF0YSkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB7IHRlYW1zLCB1c2VycyB9ID0gYXdhaXQgZ2V0Q29sbGVjdGlvbnMoKTtcclxuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XHJcbiAgICBjb25zdCBvd25lclVzZXJJZCA9IHRlYW1EYXRhLnVzZXJJZDsgLy8gQXNzdW1lIHRoaXMgaXMgdGhlIHN0cmluZyBJRCBmcm9tIHNlc3Npb25cclxuXHJcbiAgICAvLyBGZXRjaCBvd25lcidzIG5hbWVcclxuICAgIGxldCBvd25lck5hbWUgPSAnT3duZXInOyAvLyBEZWZhdWx0XHJcbiAgICBjb25zdCBvd25lclVzZXIgPSBhd2FpdCB1c2Vycy5maW5kT25lKHsgX2lkOiB0b09iamVjdElkKG93bmVyVXNlcklkKSB9ICwgeyBwcm9qZWN0aW9uOiB7IG5hbWU6IDEgfSB9KTtcclxuICAgIGlmIChvd25lclVzZXIgJiYgb3duZXJVc2VyLm5hbWUpIHtcclxuICAgICAgICBvd25lck5hbWUgPSBvd25lclVzZXIubmFtZTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBuZXdUZWFtID0ge1xyXG4gICAgICBuYW1lOiB0ZWFtRGF0YS5uYW1lLFxyXG4gICAgICBkZXNjcmlwdGlvbjogdGVhbURhdGEuZGVzY3JpcHRpb24gfHwgJycsXHJcbiAgICAgIHVzZXJJZDogb3duZXJVc2VySWQsIC8vIFN0b3JlIHRoZSBvd25lcidzIElEIChzdHJpbmcgb3IgT2JqZWN0SWQgY29uc2lzdGVudGx5KVxyXG4gICAgICBtZW1iZXJzOiBbXSwgLy8gSW5pdGlhbGl6ZSBtZW1iZXJzXHJcbiAgICAgIGNyZWF0ZWRBdDogbm93LFxyXG4gICAgICB1cGRhdGVkQXQ6IG5vdyxcclxuICAgIH07XHJcblxyXG4gICAgLy8gQWRkIGNyZWF0b3IgYXMgdGhlIG93bmVyXHJcbiAgICBuZXdUZWFtLm1lbWJlcnMucHVzaCh7XHJcbiAgICAgICAgdXNlcklkOiBvd25lclVzZXJJZCwgLy8gU3RvcmUgY29uc2lzdGVudGx5IChlLmcuLCBzdHJpbmcgSUQgZnJvbSBzZXNzaW9uKVxyXG4gICAgICAgIHJvbGU6ICdvd25lcicsXHJcbiAgICAgICAgam9pbmVkQXQ6IG5vdyxcclxuICAgICAgICBuYW1lOiBvd25lck5hbWUgLy8gQWRkIG93bmVyJ3MgbmFtZVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRlYW1zLmluc2VydE9uZShuZXdUZWFtKTtcclxuICAgIHJldHVybiB7IC4uLm5ld1RlYW0sIF9pZDogcmVzdWx0Lmluc2VydGVkSWQgfTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGNyZWF0aW5nIHRlYW06XCIsIGVycm9yKTtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIGVycm9yIHdoaWxlIGNyZWF0aW5nIHRlYW0uXCIpO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCB1cGRhdGVUZWFtID0gYXN5bmMgKGlkLCB0ZWFtRGF0YSkgPT4ge1xyXG4gIGNvbnN0IG9iamVjdElkID0gdG9PYmplY3RJZChpZCk7XHJcbiAgaWYgKCFvYmplY3RJZCkgcmV0dXJuIG51bGw7XHJcblxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB7IHRlYW1zIH0gPSBhd2FpdCBnZXRDb2xsZWN0aW9ucygpO1xyXG4gICAgY29uc3QgdXBkYXRlRG9jID0geyAkc2V0OiB7fSB9O1xyXG4gICAgaWYgKHRlYW1EYXRhLm5hbWUgIT09IHVuZGVmaW5lZCkgdXBkYXRlRG9jLiRzZXQubmFtZSA9IHRlYW1EYXRhLm5hbWU7XHJcbiAgICBpZiAodGVhbURhdGEuZGVzY3JpcHRpb24gIT09IHVuZGVmaW5lZCkgdXBkYXRlRG9jLiRzZXQuZGVzY3JpcHRpb24gPSB0ZWFtRGF0YS5kZXNjcmlwdGlvbjtcclxuICAgIHVwZGF0ZURvYy4kc2V0LnVwZGF0ZWRBdCA9IG5ldyBEYXRlKCk7XHJcblxyXG4gICAgaWYgKE9iamVjdC5rZXlzKHVwZGF0ZURvYy4kc2V0KS5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGVhbXMudXBkYXRlT25lKHsgX2lkOiBvYmplY3RJZCB9LCB1cGRhdGVEb2MpO1xyXG4gICAgICAgIGlmIChyZXN1bHQubWF0Y2hlZENvdW50ID09PSAwKSByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB1cGRhdGVkVGVhbSA9IGF3YWl0IHRlYW1zLmZpbmRPbmUoeyBfaWQ6IG9iamVjdElkIH0pO1xyXG4gICAgcmV0dXJuIHVwZGF0ZWRUZWFtO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgdXBkYXRpbmcgdGVhbTpcIiwgZXJyb3IpO1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YWJhc2UgZXJyb3Igd2hpbGUgdXBkYXRpbmcgdGVhbS5cIik7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGRlbGV0ZVRlYW0gPSBhc3luYyAoaWQpID0+IHtcclxuICBjb25zdCBvYmplY3RJZCA9IHRvT2JqZWN0SWQoaWQpO1xyXG4gIGlmICghb2JqZWN0SWQpIHJldHVybiBmYWxzZTtcclxuICB0cnkge1xyXG4gICAgY29uc3QgeyB0ZWFtcyB9ID0gYXdhaXQgZ2V0Q29sbGVjdGlvbnMoKTtcclxuICAgIC8vIFRPRE86IEhhbmRsZSByZWxhdGVkIGRhdGEgY2xlYW51cCAoZS5nLiwgcHJvbXB0cyBiZWxvbmdpbmcgdG8gdGVhbT8pXHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0ZWFtcy5kZWxldGVPbmUoeyBfaWQ6IG9iamVjdElkIH0pO1xyXG4gICAgcmV0dXJuIHJlc3VsdC5kZWxldGVkQ291bnQgPiAwO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZGVsZXRpbmcgdGVhbTpcIiwgZXJyb3IpO1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YWJhc2UgZXJyb3Igd2hpbGUgZGVsZXRpbmcgdGVhbS5cIik7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGFkZFRlYW1NZW1iZXIgPSBhc3luYyAodGVhbUlkLCBtZW1iZXJEYXRhKSA9PiB7XHJcbiAgY29uc3QgdGVhbU9iamVjdElkID0gdG9PYmplY3RJZCh0ZWFtSWQpO1xyXG4gIGlmICghdGVhbU9iamVjdElkKSByZXR1cm4gbnVsbDtcclxuICBpZiAoIW1lbWJlckRhdGEgfHwgIW1lbWJlckRhdGEudXNlcklkKSB0aHJvdyBuZXcgRXJyb3IoXCJNZW1iZXIgdXNlciBJRCBpcyByZXF1aXJlZC5cIik7XHJcblxyXG4gIGNvbnN0IG1lbWJlclVzZXJJZCA9IG1lbWJlckRhdGEudXNlcklkOyAvLyBBc3N1bWUgc3RyaW5nIElEIGZyb20gcmVxdWVzdFxyXG5cclxuICB0cnkge1xyXG4gICAgY29uc3QgeyB0ZWFtcywgdXNlcnMgfSA9IGF3YWl0IGdldENvbGxlY3Rpb25zKCk7XHJcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xyXG5cclxuICAgIC8vIEZldGNoIG1lbWJlcidzIG5hbWVcclxuICAgIGxldCBtZW1iZXJOYW1lID0gJ01lbWJlcic7IC8vIERlZmF1bHRcclxuICAgIGNvbnN0IG1lbWJlclVzZXIgPSBhd2FpdCB1c2Vycy5maW5kT25lKHsgX2lkOiB0b09iamVjdElkKG1lbWJlclVzZXJJZCkgfSwgeyBwcm9qZWN0aW9uOiB7IG5hbWU6IDEgfSB9KTtcclxuICAgICBpZiAobWVtYmVyVXNlciAmJiBtZW1iZXJVc2VyLm5hbWUpIHtcclxuICAgICAgICBtZW1iZXJOYW1lID0gbWVtYmVyVXNlci5uYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG1lbWJlclJlY29yZCA9IHtcclxuICAgICAgdXNlcklkOiBtZW1iZXJVc2VySWQsIC8vIFN0b3JlIGNvbnNpc3RlbnRseSBhcyBzdHJpbmdcclxuICAgICAgcm9sZTogbWVtYmVyRGF0YS5yb2xlIHx8ICdtZW1iZXInLFxyXG4gICAgICBqb2luZWRBdDogbm93LFxyXG4gICAgICBuYW1lOiBtZW1iZXJOYW1lIC8vIEFkZCBtZW1iZXIncyBuYW1lXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIENoZWNrIGlmIHVzZXIgaXMgYWxyZWFkeSBhIG1lbWJlciAodXNpbmcgdGhlIHN0cmluZyBJRClcclxuICAgIGNvbnN0IHRlYW0gPSBhd2FpdCB0ZWFtcy5maW5kT25lKHsgX2lkOiB0ZWFtT2JqZWN0SWQsICdtZW1iZXJzLnVzZXJJZCc6IG1lbWJlclVzZXJJZCB9KTtcclxuICAgIGlmICh0ZWFtKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJVc2VyIGlzIGFscmVhZHkgYSBtZW1iZXIgb2YgdGhpcyB0ZWFtLlwiKTtcclxuICAgICAgICByZXR1cm4gdGVhbTsgLy8gQWxyZWFkeSBhIG1lbWJlclxyXG4gICAgfVxyXG5cclxuICAgIC8vIFVzZSAkYWRkVG9TZXQgKG9yICRwdXNoIGlmIGR1cGxpY2F0ZXMgYXJlIGltcG9zc2libGUvdW5kZXNpcmVkKVxyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGVhbXMudXBkYXRlT25lKFxyXG4gICAgICB7IF9pZDogdGVhbU9iamVjdElkIH0sXHJcbiAgICAgIHsgXHJcbiAgICAgICAgJHB1c2g6IHsgbWVtYmVyczogbWVtYmVyUmVjb3JkIH0sIC8vIFVzZSAkcHVzaCBzaW5jZSB3ZSBjaGVja2VkIGV4aXN0ZW5jZVxyXG4gICAgICAgICRzZXQ6IHsgdXBkYXRlZEF0OiBub3cgfSBcclxuICAgICAgfVxyXG4gICAgKTtcclxuXHJcbiAgICBpZiAocmVzdWx0Lm1hdGNoZWRDb3VudCA9PT0gMCkgcmV0dXJuIG51bGw7XHJcbiAgICBcclxuICAgIGNvbnN0IHVwZGF0ZWRUZWFtID0gYXdhaXQgdGVhbXMuZmluZE9uZSh7IF9pZDogdGVhbU9iamVjdElkIH0pO1xyXG4gICAgcmV0dXJuIHVwZGF0ZWRUZWFtO1xyXG4gICAgXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBhZGRpbmcgdGVhbSBtZW1iZXI6XCIsIGVycm9yKTtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIGVycm9yIHdoaWxlIGFkZGluZyB0ZWFtIG1lbWJlci5cIik7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHJlbW92ZVRlYW1NZW1iZXIgPSBhc3luYyAodGVhbUlkLCB1c2VySWRUb1JlbW92ZSkgPT4ge1xyXG4gIGNvbnN0IHRlYW1PYmplY3RJZCA9IHRvT2JqZWN0SWQodGVhbUlkKTtcclxuICBpZiAoIXRlYW1PYmplY3RJZCkgcmV0dXJuIG51bGw7XHJcbiAgaWYgKCF1c2VySWRUb1JlbW92ZSkgdGhyb3cgbmV3IEVycm9yKFwiVXNlciBJRCB0byByZW1vdmUgaXMgcmVxdWlyZWQuXCIpO1xyXG5cclxuICBjb25zdCBtZW1iZXJVc2VySWRTdHJpbmcgPSB1c2VySWRUb1JlbW92ZS50b1N0cmluZygpO1xyXG5cclxuICB0cnkge1xyXG4gICAgY29uc3QgeyB0ZWFtcyB9ID0gYXdhaXQgZ2V0Q29sbGVjdGlvbnMoKTtcclxuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XHJcblxyXG4gICAgLy8gRmluZCB0aGUgdGVhbSBmaXJzdCB0byBjaGVjayBpZiB0aGUgdXNlciBiZWluZyByZW1vdmVkIGlzIHRoZSBvd25lclxyXG4gICAgY29uc3QgdGVhbSA9IGF3YWl0IHRlYW1zLmZpbmRPbmUoeyBfaWQ6IHRlYW1PYmplY3RJZCB9KTtcclxuICAgIGlmICghdGVhbSkgcmV0dXJuIG51bGw7IC8vIFRlYW0gbm90IGZvdW5kXHJcblxyXG4gICAgY29uc3QgbWVtYmVyVG9SZW1vdmUgPSB0ZWFtLm1lbWJlcnMuZmluZChtID0+IG0udXNlcklkID09PSBtZW1iZXJVc2VySWRTdHJpbmcpO1xyXG4gICAgaWYgKCFtZW1iZXJUb1JlbW92ZSkge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiTWVtYmVyIG5vdCBmb3VuZCBpbiB0ZWFtLlwiKTtcclxuICAgICAgICByZXR1cm4gdGVhbTsgLy8gTWVtYmVyIG5vdCBmb3VuZCwgcmV0dXJuIGN1cnJlbnQgdGVhbSBzdGF0ZVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFByZXZlbnQgcmVtb3ZpbmcgdGhlIG93bmVyXHJcbiAgICBpZiAobWVtYmVyVG9SZW1vdmUucm9sZSA9PT0gJ293bmVyJykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZW1vdmUgdGhlIHRlYW0gb3duZXIuXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFVzZSAkcHVsbCB0byByZW1vdmUgdGhlIG1lbWJlciBieSB1c2VySWQgKHN0cmluZyBtYXRjaClcclxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRlYW1zLnVwZGF0ZU9uZShcclxuICAgICAgeyBfaWQ6IHRlYW1PYmplY3RJZCB9LFxyXG4gICAgICB7IFxyXG4gICAgICAgICRwdWxsOiB7IG1lbWJlcnM6IHsgdXNlcklkOiBtZW1iZXJVc2VySWRTdHJpbmcgfSB9LCBcclxuICAgICAgICAkc2V0OiB7IHVwZGF0ZWRBdDogbm93IH1cclxuICAgICAgfVxyXG4gICAgKTtcclxuXHJcbiAgICBpZiAocmVzdWx0Lm1vZGlmaWVkQ291bnQgPT09IDApIHtcclxuICAgICAgLy8gU2hvdWxkIG5vdCBoYXBwZW4gaWYgbWVtYmVyIHdhcyBmb3VuZCwgYnV0IGhhbmRsZSBncmFjZWZ1bGx5XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiUHVsbCBvcGVyYXRpb24gZGlkIG5vdCBtb2RpZnkgdGhlIGRvY3VtZW50LlwiKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB1cGRhdGVkVGVhbSA9IGF3YWl0IHRlYW1zLmZpbmRPbmUoeyBfaWQ6IHRlYW1PYmplY3RJZCB9KTtcclxuICAgIHJldHVybiB1cGRhdGVkVGVhbTtcclxuXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciByZW1vdmluZyB0ZWFtIG1lbWJlcjpcIiwgZXJyb3IpO1xyXG4gICAgaWYgKGVycm9yLm1lc3NhZ2UgPT09IFwiQ2Fubm90IHJlbW92ZSB0aGUgdGVhbSBvd25lci5cIikge1xyXG4gICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YWJhc2UgZXJyb3Igd2hpbGUgcmVtb3ZpbmcgdGVhbSBtZW1iZXIuXCIpO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIFRPRE86IEltcGxlbWVudCB1cGRhdGVUZWFtTWVtYmVyIHJvbGUgaWYgbmVlZGVkXHJcblxyXG4vLyAtLS0gQ29tbWVudCBGdW5jdGlvbnMgLS0tXHJcblxyXG5leHBvcnQgY29uc3QgZ2V0Q29tbWVudHNCeVByb21wdElkID0gYXN5bmMgKHByb21wdElkKSA9PiB7XHJcbiAgY29uc3QgcHJvbXB0T2JqZWN0SWQgPSB0b09iamVjdElkKHByb21wdElkKTtcclxuICBpZiAoIXByb21wdE9iamVjdElkKSByZXR1cm4gW107XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHsgY29tbWVudHMgfSA9IGF3YWl0IGdldENvbGxlY3Rpb25zKCk7XHJcbiAgICAvLyBGZXRjaCBjb21tZW50cyBhbmQgc29ydCBieSBjcmVhdGlvbiBkYXRlIChuZXdlc3QgZmlyc3QpXHJcbiAgICBjb25zdCBwcm9tcHRDb21tZW50cyA9IGF3YWl0IGNvbW1lbnRzLmZpbmQoeyBwcm9tcHRJZDogcHJvbXB0T2JqZWN0SWQgfSkuc29ydCh7IGNyZWF0ZWRBdDogLTEgfSkudG9BcnJheSgpO1xyXG4gICAgcmV0dXJuIHByb21wdENvbW1lbnRzO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgY29tbWVudHMgYnkgcHJvbXB0IElEOlwiLCBlcnJvcik7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhYmFzZSBlcnJvciB3aGlsZSBmZXRjaGluZyBjb21tZW50cy5cIik7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNyZWF0ZUNvbW1lbnQgPSBhc3luYyAoY29tbWVudERhdGEpID0+IHtcclxuICBpZiAoIWNvbW1lbnREYXRhLnByb21wdElkIHx8ICFjb21tZW50RGF0YS51c2VySWQgfHwgIWNvbW1lbnREYXRhLmNvbnRlbnQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIlByb21wdCBJRCwgVXNlciBJRCwgYW5kIGNvbnRlbnQgYXJlIHJlcXVpcmVkIGZvciBjb21tZW50cy5cIik7XHJcbiAgfVxyXG4gIGNvbnN0IHByb21wdE9iamVjdElkID0gdG9PYmplY3RJZChjb21tZW50RGF0YS5wcm9tcHRJZCk7XHJcbiAgLy8gQXNzdW1pbmcgdXNlcklkIGlzIHBhc3NlZCBhcyBzdHJpbmcgZnJvbSBzZXNzaW9uXHJcbiAgY29uc3QgdXNlcklkU3RyaW5nID0gY29tbWVudERhdGEudXNlcklkLnRvU3RyaW5nKCk7IFxyXG5cclxuICBpZiAoIXByb21wdE9iamVjdElkKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFByb21wdCBJRCBmb3JtYXQgZm9yIGNvbW1lbnQuXCIpO1xyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHsgY29tbWVudHMsIHVzZXJzIH0gPSBhd2FpdCBnZXRDb2xsZWN0aW9ucygpO1xyXG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcclxuXHJcbiAgICAvLyBGZXRjaCBjb21tZW50ZXIncyBuYW1lXHJcbiAgICBsZXQgY3JlYXRlZEJ5TmFtZSA9ICdVc2VyJzsgLy8gRGVmYXVsdFxyXG4gICAgY29uc3QgY29tbWVudGVyVXNlciA9IGF3YWl0IHVzZXJzLmZpbmRPbmUoeyBfaWQ6IHRvT2JqZWN0SWQodXNlcklkU3RyaW5nKSB9LCB7IHByb2plY3Rpb246IHsgbmFtZTogMSB9IH0pO1xyXG4gICAgaWYgKGNvbW1lbnRlclVzZXIgJiYgY29tbWVudGVyVXNlci5uYW1lKSB7XHJcbiAgICAgICAgY3JlYXRlZEJ5TmFtZSA9IGNvbW1lbnRlclVzZXIubmFtZTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBuZXdDb21tZW50ID0ge1xyXG4gICAgICBwcm9tcHRJZDogcHJvbXB0T2JqZWN0SWQsXHJcbiAgICAgIHVzZXJJZDogdXNlcklkU3RyaW5nLCAvLyBTdG9yZSB1c2VySWQgY29uc2lzdGVudGx5IChlLmcuLCBzdHJpbmcpXHJcbiAgICAgIGNvbnRlbnQ6IGNvbW1lbnREYXRhLmNvbnRlbnQsXHJcbiAgICAgIGNyZWF0ZWRCeTogY3JlYXRlZEJ5TmFtZSwgLy8gU3RvcmUgY29tbWVudGVyJ3MgbmFtZVxyXG4gICAgICBjcmVhdGVkQXQ6IG5vdyxcclxuICAgICAgdXBkYXRlZEF0OiBub3csXHJcbiAgICB9O1xyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29tbWVudHMuaW5zZXJ0T25lKG5ld0NvbW1lbnQpO1xyXG4gICAgcmV0dXJuIHsgLi4ubmV3Q29tbWVudCwgX2lkOiByZXN1bHQuaW5zZXJ0ZWRJZCB9O1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY3JlYXRpbmcgY29tbWVudDpcIiwgZXJyb3IpO1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YWJhc2UgZXJyb3Igd2hpbGUgY3JlYXRpbmcgY29tbWVudC5cIik7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHVwZGF0ZUNvbW1lbnQgPSBhc3luYyAoaWQsIGNvbW1lbnREYXRhKSA9PiB7XHJcbiAgY29uc3Qgb2JqZWN0SWQgPSB0b09iamVjdElkKGlkKTtcclxuICBpZiAoIW9iamVjdElkKSByZXR1cm4gbnVsbDtcclxuICBpZiAoIWNvbW1lbnREYXRhLmNvbnRlbnQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIkNvbW1lbnQgY29udGVudCBpcyByZXF1aXJlZCBmb3IgdXBkYXRlLlwiKTtcclxuICB9XHJcblxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB7IGNvbW1lbnRzIH0gPSBhd2FpdCBnZXRDb2xsZWN0aW9ucygpO1xyXG4gICAgY29uc3QgdXBkYXRlRG9jID0ge1xyXG4gICAgICAkc2V0OiB7XHJcbiAgICAgICAgY29udGVudDogY29tbWVudERhdGEuY29udGVudCxcclxuICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCksXHJcbiAgICAgIH0sXHJcbiAgICB9O1xyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29tbWVudHMudXBkYXRlT25lKHsgX2lkOiBvYmplY3RJZCB9LCB1cGRhdGVEb2MpO1xyXG4gICAgaWYgKHJlc3VsdC5tYXRjaGVkQ291bnQgPT09IDApIHJldHVybiBudWxsO1xyXG5cclxuICAgIGNvbnN0IHVwZGF0ZWRDb21tZW50ID0gYXdhaXQgY29tbWVudHMuZmluZE9uZSh7IF9pZDogb2JqZWN0SWQgfSk7XHJcbiAgICByZXR1cm4gdXBkYXRlZENvbW1lbnQ7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciB1cGRhdGluZyBjb21tZW50OlwiLCBlcnJvcik7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhYmFzZSBlcnJvciB3aGlsZSB1cGRhdGluZyBjb21tZW50LlwiKTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZGVsZXRlQ29tbWVudCA9IGFzeW5jIChpZCkgPT4ge1xyXG4gIGNvbnN0IG9iamVjdElkID0gdG9PYmplY3RJZChpZCk7XHJcbiAgaWYgKCFvYmplY3RJZCkgcmV0dXJuIGZhbHNlO1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB7IGNvbW1lbnRzIH0gPSBhd2FpdCBnZXRDb2xsZWN0aW9ucygpO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29tbWVudHMuZGVsZXRlT25lKHsgX2lkOiBvYmplY3RJZCB9KTtcclxuICAgIHJldHVybiByZXN1bHQuZGVsZXRlZENvdW50ID4gMDtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGRlbGV0aW5nIGNvbW1lbnQ6XCIsIGVycm9yKTtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIGVycm9yIHdoaWxlIGRlbGV0aW5nIGNvbW1lbnQuXCIpO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIFJlbW92ZSB0aGUgb2xkIGluLW1lbW9yeSBkYXRhIGFuZCBpbml0aWFsaXphdGlvbiBsb2dpY1xyXG4vKlxyXG5sZXQgcHJvbXB0cyA9IFtdO1xyXG5sZXQgY29sbGVjdGlvbnMgPSBbXTtcclxubGV0IHVzZXJzID0gW107XHJcbmxldCB0ZWFtcyA9IFtdO1xyXG5sZXQgY29tbWVudHMgPSBbXTtcclxubGV0IHByb21wdElkQ291bnRlciA9IDE7XHJcbmxldCBjb2xsZWN0aW9uSWRDb3VudGVyID0gMTtcclxubGV0IHVzZXJJZENvdW50ZXIgPSAxO1xyXG5sZXQgdGVhbUlkQ291bnRlciA9IDE7XHJcbmxldCBjb21tZW50SWRDb3VudGVyID0gMTtcclxuXHJcbi8vIEFsbCBvbGQgZnVuY3Rpb25zIGxpa2U6XHJcbmV4cG9ydCBjb25zdCBnZXRBbGxQcm9tcHRzID0gKCkgPT4geyAuLi4gfTtcclxuLy8gLi4uIGV0Yy5cclxuXHJcbi8vIEluaXRpYWxpemUgd2l0aCBzb21lIHNhbXBsZSBkYXRhIC0gaW4gcmVhbCBhcHAsIHRoaXMgd291bGQgYmUgbG9hZGVkIGZyb20gZGF0YWJhc2VcclxuZXhwb3J0IGNvbnN0IGluaXRpYWxpemVEYiA9IGFzeW5jICgpID0+IHsgLi4uIH07XHJcblxyXG4vLyBDYWxsIGluaXRpYWxpemUgd2hlbiBpbXBvcnRlZFxyXG4oYXN5bmMgKCkgPT4geyAuLi4gfSkoKTtcclxuKi9cclxuIl0sIm5hbWVzIjpbImNvbm5lY3RUb0RhdGFiYXNlIiwiT2JqZWN0SWQiLCJoYXNoUGFzc3dvcmQiLCJnZXRDb2xsZWN0aW9ucyIsImRiIiwidXNlcnMiLCJjb2xsZWN0aW9uIiwicHJvbXB0cyIsImNvbGxlY3Rpb25zIiwidGVhbXMiLCJjb21tZW50cyIsInRvT2JqZWN0SWQiLCJpZCIsImlzVmFsaWQiLCJlcnJvciIsImNvbnNvbGUiLCJnZXRBbGxQcm9tcHRzIiwiZmlsdGVyIiwib3B0aW9ucyIsImN1cnNvciIsImZpbmQiLCJzb3J0IiwiY3JlYXRlZEF0IiwibGltaXQiLCJza2lwIiwiYWxsUHJvbXB0cyIsInRvQXJyYXkiLCJFcnJvciIsImdldFByb21wdEJ5SWQiLCJvYmplY3RJZCIsInByb21wdCIsImZpbmRPbmUiLCJfaWQiLCJjcmVhdGVQcm9tcHQiLCJwcm9tcHREYXRhIiwibm93IiwiRGF0ZSIsIm5ld1Byb21wdCIsInRpdGxlIiwiY29udGVudCIsImRlc2NyaXB0aW9uIiwidGFncyIsImFpUGxhdGZvcm0iLCJyYXRpbmciLCJ1c2FnZUNvdW50Iiwic3VjY2Vzc1JhdGUiLCJ2aXNpYmlsaXR5IiwidXNlcklkIiwiY3JlYXRlZEJ5IiwidGVhbUlkIiwidXBkYXRlZEF0IiwicmVzdWx0IiwiaW5zZXJ0T25lIiwiaW5zZXJ0ZWRJZCIsInVwZGF0ZVByb21wdCIsInVwZGF0ZURvYyIsIiRzZXQiLCJrZXkiLCJ1bmRlZmluZWQiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwidXBkYXRlT25lIiwibWF0Y2hlZENvdW50IiwidXBkYXRlZFByb21wdCIsImRlbGV0ZVByb21wdCIsImRlbGV0ZU9uZSIsImRlbGV0ZWRDb3VudCIsImdldEFsbENvbGxlY3Rpb25zIiwiYWxsQ29sbGVjdGlvbnMiLCJnZXRDb2xsZWN0aW9uQnlJZCIsImNyZWF0ZUNvbGxlY3Rpb24iLCJjb2xsZWN0aW9uRGF0YSIsIm5ld0NvbGxlY3Rpb24iLCJuYW1lIiwidXBkYXRlQ29sbGVjdGlvbiIsInVwZGF0ZWRDb2xsZWN0aW9uIiwiZGVsZXRlQ29sbGVjdGlvbiIsImFkZFByb21wdFRvQ29sbGVjdGlvbiIsImNvbGxlY3Rpb25JZCIsInByb21wdElkIiwiY29sbE9iamVjdElkIiwicHJvbXB0T2JqZWN0SWQiLCIkYWRkVG9TZXQiLCJyZW1vdmVQcm9tcHRGcm9tQ29sbGVjdGlvbiIsIiRwdWxsIiwiZ2V0QWxsVXNlcnMiLCJwcm9qZWN0aW9uIiwicGFzc3dvcmQiLCJhbGxVc2VycyIsImdldFVzZXJCeUlkIiwidXNlciIsImdldFVzZXJCeUVtYWlsIiwiZW1haWwiLCJ0b0xvd2VyQ2FzZSIsImNyZWF0ZVVzZXIiLCJ1c2VyRGF0YSIsImV4aXN0aW5nVXNlciIsImhhc2hlZFBhc3N3b3JkIiwibmV3VXNlciIsImltYWdlIiwidXNlcldpdGhvdXRQYXNzd29yZCIsIm1lc3NhZ2UiLCJ1cGRhdGVVc2VyIiwibmV3RW1haWwiLCJlcXVhbHMiLCJ1cGRhdGVkVXNlciIsImRlbGV0ZVVzZXIiLCJnZXRUZWFtQnlJZCIsInRlYW0iLCJnZXRUZWFtc0J5VXNlcklkIiwidXNlcklkU3RyaW5nIiwidG9TdHJpbmciLCJ1c2VyT2JqZWN0SWQiLCJxdWVyeSIsIm93bmVyUXVlcnkiLCJmaW5hbFF1ZXJ5IiwiJG9yIiwicHVzaCIsInVzZXJUZWFtcyIsImNyZWF0ZVRlYW0iLCJ0ZWFtRGF0YSIsIm93bmVyVXNlcklkIiwib3duZXJOYW1lIiwib3duZXJVc2VyIiwibmV3VGVhbSIsIm1lbWJlcnMiLCJyb2xlIiwiam9pbmVkQXQiLCJ1cGRhdGVUZWFtIiwidXBkYXRlZFRlYW0iLCJkZWxldGVUZWFtIiwiYWRkVGVhbU1lbWJlciIsIm1lbWJlckRhdGEiLCJ0ZWFtT2JqZWN0SWQiLCJtZW1iZXJVc2VySWQiLCJtZW1iZXJOYW1lIiwibWVtYmVyVXNlciIsIm1lbWJlclJlY29yZCIsImxvZyIsIiRwdXNoIiwicmVtb3ZlVGVhbU1lbWJlciIsInVzZXJJZFRvUmVtb3ZlIiwibWVtYmVyVXNlcklkU3RyaW5nIiwibWVtYmVyVG9SZW1vdmUiLCJtIiwibW9kaWZpZWRDb3VudCIsImdldENvbW1lbnRzQnlQcm9tcHRJZCIsInByb21wdENvbW1lbnRzIiwiY3JlYXRlQ29tbWVudCIsImNvbW1lbnREYXRhIiwiY3JlYXRlZEJ5TmFtZSIsImNvbW1lbnRlclVzZXIiLCJuZXdDb21tZW50IiwidXBkYXRlQ29tbWVudCIsInVwZGF0ZWRDb21tZW50IiwiZGVsZXRlQ29tbWVudCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api-node)/./lib/db.js\n");

/***/ }),

/***/ "(api-node)/./lib/mongodb.js":
/*!************************!*\
  !*** ./lib/mongodb.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closeDatabaseConnection: () => (/* binding */ closeDatabaseConnection),\n/* harmony export */   connectToDatabase: () => (/* binding */ connectToDatabase),\n/* harmony export */   getCollection: () => (/* binding */ getCollection)\n/* harmony export */ });\n/* harmony import */ var mongodb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mongodb */ \"mongodb\");\n/* harmony import */ var mongodb__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(mongodb__WEBPACK_IMPORTED_MODULE_0__);\n\nconst uri = process.env.MONGODB_URI;\nconst dbName = process.env.MONGODB_DB;\nif (!uri) {\n    throw new Error('Please define the MONGODB_URI environment variable inside .env.local');\n}\nif (!dbName) {\n    throw new Error('Please define the MONGODB_DB environment variable inside .env.local');\n}\nlet cachedClient = null;\nlet cachedDb = null;\n/**\r\n * Connects to the MongoDB database and returns the client and db instances.\r\n * Caches the connection to avoid reconnecting on every request in development.\r\n */ async function connectToDatabase() {\n    if (cachedClient && cachedDb) {\n        return {\n            client: cachedClient,\n            db: cachedDb\n        };\n    }\n    try {\n        const client = new mongodb__WEBPACK_IMPORTED_MODULE_0__.MongoClient(uri, {\n        });\n        await client.connect();\n        const db = client.db(dbName);\n        console.log(\"Successfully connected to MongoDB.\");\n        cachedClient = client;\n        cachedDb = db;\n        return {\n            client,\n            db\n        };\n    } catch (error) {\n        console.error(\"Failed to connect to MongoDB\", error);\n        throw new Error(\"Could not connect to database.\");\n    }\n}\n// Optional: Helper to close the connection (useful for scripts or tests)\nasync function closeDatabaseConnection() {\n    if (cachedClient) {\n        await cachedClient.close();\n        cachedClient = null;\n        cachedDb = null;\n        console.log(\"MongoDB connection closed.\");\n    }\n}\n// Helper function to get collection references\nasync function getCollection(collectionName) {\n    const { db } = await connectToDatabase();\n    return db.collection(collectionName);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uL2xpYi9tb25nb2RiLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXNDO0FBRXRDLE1BQU1DLE1BQU1DLFFBQVFDLEdBQUcsQ0FBQ0MsV0FBVztBQUNuQyxNQUFNQyxTQUFTSCxRQUFRQyxHQUFHLENBQUNHLFVBQVU7QUFFckMsSUFBSSxDQUFDTCxLQUFLO0lBQ1IsTUFBTSxJQUFJTSxNQUFNO0FBQ2xCO0FBRUEsSUFBSSxDQUFDRixRQUFRO0lBQ1gsTUFBTSxJQUFJRSxNQUFNO0FBQ2xCO0FBRUEsSUFBSUMsZUFBZTtBQUNuQixJQUFJQyxXQUFXO0FBRWY7OztDQUdDLEdBQ00sZUFBZUM7SUFDcEIsSUFBSUYsZ0JBQWdCQyxVQUFVO1FBQzVCLE9BQU87WUFBRUUsUUFBUUg7WUFBY0ksSUFBSUg7UUFBUztJQUM5QztJQUVBLElBQUk7UUFDRixNQUFNRSxTQUFTLElBQUlYLGdEQUFXQSxDQUFDQyxLQUFLO1FBR3BDO1FBRUEsTUFBTVUsT0FBT0UsT0FBTztRQUNwQixNQUFNRCxLQUFLRCxPQUFPQyxFQUFFLENBQUNQO1FBRXJCUyxRQUFRQyxHQUFHLENBQUM7UUFFWlAsZUFBZUc7UUFDZkYsV0FBV0c7UUFFWCxPQUFPO1lBQUVEO1lBQVFDO1FBQUc7SUFDdEIsRUFBRSxPQUFPSSxPQUFPO1FBQ2RGLFFBQVFFLEtBQUssQ0FBQyxnQ0FBZ0NBO1FBQzlDLE1BQU0sSUFBSVQsTUFBTTtJQUNsQjtBQUNGO0FBRUEseUVBQXlFO0FBQ2xFLGVBQWVVO0lBQ3BCLElBQUlULGNBQWM7UUFDaEIsTUFBTUEsYUFBYVUsS0FBSztRQUN4QlYsZUFBZTtRQUNmQyxXQUFXO1FBQ1hLLFFBQVFDLEdBQUcsQ0FBQztJQUNkO0FBQ0Y7QUFFQSwrQ0FBK0M7QUFDeEMsZUFBZUksY0FBY0MsY0FBYztJQUNoRCxNQUFNLEVBQUVSLEVBQUUsRUFBRSxHQUFHLE1BQU1GO0lBQ3JCLE9BQU9FLEdBQUdTLFVBQVUsQ0FBQ0Q7QUFDdkIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcYmF1ZGlcXE9uZURyaXZlXFxEZXNrdG9wXFxQcm9tcHRQcm9cXFByb21wdFByb1xcbGliXFxtb25nb2RiLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1vbmdvQ2xpZW50IH0gZnJvbSAnbW9uZ29kYic7XHJcblxyXG5jb25zdCB1cmkgPSBwcm9jZXNzLmVudi5NT05HT0RCX1VSSTtcclxuY29uc3QgZGJOYW1lID0gcHJvY2Vzcy5lbnYuTU9OR09EQl9EQjtcclxuXHJcbmlmICghdXJpKSB7XHJcbiAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgZGVmaW5lIHRoZSBNT05HT0RCX1VSSSBlbnZpcm9ubWVudCB2YXJpYWJsZSBpbnNpZGUgLmVudi5sb2NhbCcpO1xyXG59XHJcblxyXG5pZiAoIWRiTmFtZSkge1xyXG4gIHRocm93IG5ldyBFcnJvcignUGxlYXNlIGRlZmluZSB0aGUgTU9OR09EQl9EQiBlbnZpcm9ubWVudCB2YXJpYWJsZSBpbnNpZGUgLmVudi5sb2NhbCcpO1xyXG59XHJcblxyXG5sZXQgY2FjaGVkQ2xpZW50ID0gbnVsbDtcclxubGV0IGNhY2hlZERiID0gbnVsbDtcclxuXHJcbi8qKlxyXG4gKiBDb25uZWN0cyB0byB0aGUgTW9uZ29EQiBkYXRhYmFzZSBhbmQgcmV0dXJucyB0aGUgY2xpZW50IGFuZCBkYiBpbnN0YW5jZXMuXHJcbiAqIENhY2hlcyB0aGUgY29ubmVjdGlvbiB0byBhdm9pZCByZWNvbm5lY3Rpbmcgb24gZXZlcnkgcmVxdWVzdCBpbiBkZXZlbG9wbWVudC5cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb25uZWN0VG9EYXRhYmFzZSgpIHtcclxuICBpZiAoY2FjaGVkQ2xpZW50ICYmIGNhY2hlZERiKSB7XHJcbiAgICByZXR1cm4geyBjbGllbnQ6IGNhY2hlZENsaWVudCwgZGI6IGNhY2hlZERiIH07XHJcbiAgfVxyXG5cclxuICB0cnkge1xyXG4gICAgY29uc3QgY2xpZW50ID0gbmV3IE1vbmdvQ2xpZW50KHVyaSwge1xyXG4gICAgICAvLyB1c2VOZXdVcmxQYXJzZXI6IHRydWUsIC8vIERlcHJlY2F0ZWQgaW4gbmV3ZXIgdmVyc2lvbnNcclxuICAgICAgLy8gdXNlVW5pZmllZFRvcG9sb2d5OiB0cnVlLCAvLyBEZXByZWNhdGVkIGluIG5ld2VyIHZlcnNpb25zXHJcbiAgICB9KTtcclxuXHJcbiAgICBhd2FpdCBjbGllbnQuY29ubmVjdCgpO1xyXG4gICAgY29uc3QgZGIgPSBjbGllbnQuZGIoZGJOYW1lKTtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhcIlN1Y2Nlc3NmdWxseSBjb25uZWN0ZWQgdG8gTW9uZ29EQi5cIik7XHJcblxyXG4gICAgY2FjaGVkQ2xpZW50ID0gY2xpZW50O1xyXG4gICAgY2FjaGVkRGIgPSBkYjtcclxuXHJcbiAgICByZXR1cm4geyBjbGllbnQsIGRiIH07XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gY29ubmVjdCB0byBNb25nb0RCXCIsIGVycm9yKTtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBjb25uZWN0IHRvIGRhdGFiYXNlLlwiKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIE9wdGlvbmFsOiBIZWxwZXIgdG8gY2xvc2UgdGhlIGNvbm5lY3Rpb24gKHVzZWZ1bCBmb3Igc2NyaXB0cyBvciB0ZXN0cylcclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNsb3NlRGF0YWJhc2VDb25uZWN0aW9uKCkge1xyXG4gIGlmIChjYWNoZWRDbGllbnQpIHtcclxuICAgIGF3YWl0IGNhY2hlZENsaWVudC5jbG9zZSgpO1xyXG4gICAgY2FjaGVkQ2xpZW50ID0gbnVsbDtcclxuICAgIGNhY2hlZERiID0gbnVsbDtcclxuICAgIGNvbnNvbGUubG9nKFwiTW9uZ29EQiBjb25uZWN0aW9uIGNsb3NlZC5cIik7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IGNvbGxlY3Rpb24gcmVmZXJlbmNlc1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q29sbGVjdGlvbihjb2xsZWN0aW9uTmFtZSkge1xyXG4gIGNvbnN0IHsgZGIgfSA9IGF3YWl0IGNvbm5lY3RUb0RhdGFiYXNlKCk7XHJcbiAgcmV0dXJuIGRiLmNvbGxlY3Rpb24oY29sbGVjdGlvbk5hbWUpO1xyXG59ICJdLCJuYW1lcyI6WyJNb25nb0NsaWVudCIsInVyaSIsInByb2Nlc3MiLCJlbnYiLCJNT05HT0RCX1VSSSIsImRiTmFtZSIsIk1PTkdPREJfREIiLCJFcnJvciIsImNhY2hlZENsaWVudCIsImNhY2hlZERiIiwiY29ubmVjdFRvRGF0YWJhc2UiLCJjbGllbnQiLCJkYiIsImNvbm5lY3QiLCJjb25zb2xlIiwibG9nIiwiZXJyb3IiLCJjbG9zZURhdGFiYXNlQ29ubmVjdGlvbiIsImNsb3NlIiwiZ2V0Q29sbGVjdGlvbiIsImNvbGxlY3Rpb25OYW1lIiwiY29sbGVjdGlvbiJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api-node)/./lib/mongodb.js\n");

/***/ }),

/***/ "(api-node)/./lib/repositories/promptRepository.js":
/*!**********************************************!*\
  !*** ./lib/repositories/promptRepository.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createPrompt: () => (/* binding */ createPrompt),\n/* harmony export */   deletePrompt: () => (/* binding */ deletePrompt),\n/* harmony export */   getAllPrompts: () => (/* binding */ getAllPrompts),\n/* harmony export */   getPromptById: () => (/* binding */ getPromptById),\n/* harmony export */   incrementUsageCount: () => (/* binding */ incrementUsageCount),\n/* harmony export */   searchPrompts: () => (/* binding */ searchPrompts),\n/* harmony export */   updatePrompt: () => (/* binding */ updatePrompt)\n/* harmony export */ });\n/* harmony import */ var _mongodb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mongodb */ \"(api-node)/./lib/mongodb.js\");\n/* harmony import */ var mongodb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mongodb */ \"mongodb\");\n/* harmony import */ var mongodb__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(mongodb__WEBPACK_IMPORTED_MODULE_1__);\n\n\nconst COLLECTION_NAME = 'prompts';\n/**\r\n * Get all prompts with optional filtering\r\n * @param {Object} filter - Optional filter criteria\r\n * @returns {Promise<Array>} Array of prompts\r\n */ async function getAllPrompts(filter = {}) {\n    const collection = await (0,_mongodb__WEBPACK_IMPORTED_MODULE_0__.getCollection)(COLLECTION_NAME);\n    const prompts = await collection.find(filter).toArray();\n    return prompts.map(mapMongoPrompt);\n}\n/**\r\n * Get a single prompt by ID\r\n * @param {string} id - Prompt ID\r\n * @returns {Promise<Object|null>} Prompt object or null\r\n */ async function getPromptById(id) {\n    const collection = await (0,_mongodb__WEBPACK_IMPORTED_MODULE_0__.getCollection)(COLLECTION_NAME);\n    const prompt = await collection.findOne({\n        _id: new mongodb__WEBPACK_IMPORTED_MODULE_1__.ObjectId(id)\n    });\n    return prompt ? mapMongoPrompt(prompt) : null;\n}\n/**\r\n * Create a new prompt\r\n * @param {Object} promptData - Prompt data\r\n * @returns {Promise<Object>} Created prompt\r\n */ async function createPrompt(promptData) {\n    const collection = await (0,_mongodb__WEBPACK_IMPORTED_MODULE_0__.getCollection)(COLLECTION_NAME);\n    const newPrompt = {\n        ...promptData,\n        createdAt: new Date(),\n        updatedAt: new Date(),\n        usageCount: 0,\n        rating: promptData.rating || 0\n    };\n    const result = await collection.insertOne(newPrompt);\n    return {\n        id: result.insertedId.toString(),\n        ...newPrompt\n    };\n}\n/**\r\n * Update an existing prompt\r\n * @param {string} id - Prompt ID\r\n * @param {Object} promptData - Updated prompt data\r\n * @returns {Promise<Object|null>} Updated prompt or null\r\n */ async function updatePrompt(id, promptData) {\n    const collection = await (0,_mongodb__WEBPACK_IMPORTED_MODULE_0__.getCollection)(COLLECTION_NAME);\n    const updatedPrompt = {\n        ...promptData,\n        updatedAt: new Date()\n    };\n    // Don't override these fields if not explicitly provided\n    delete updatedPrompt._id;\n    delete updatedPrompt.id;\n    delete updatedPrompt.createdAt;\n    const result = await collection.findOneAndUpdate({\n        _id: new mongodb__WEBPACK_IMPORTED_MODULE_1__.ObjectId(id)\n    }, {\n        $set: updatedPrompt\n    }, {\n        returnDocument: 'after'\n    });\n    return result.value ? mapMongoPrompt(result.value) : null;\n}\n/**\r\n * Delete a prompt\r\n * @param {string} id - Prompt ID\r\n * @returns {Promise<boolean>} Success flag\r\n */ async function deletePrompt(id) {\n    const collection = await (0,_mongodb__WEBPACK_IMPORTED_MODULE_0__.getCollection)(COLLECTION_NAME);\n    const result = await collection.deleteOne({\n        _id: new mongodb__WEBPACK_IMPORTED_MODULE_1__.ObjectId(id)\n    });\n    return result.deletedCount === 1;\n}\n/**\r\n * Increment prompt usage count\r\n * @param {string} id - Prompt ID\r\n * @returns {Promise<Object|null>} Updated prompt or null\r\n */ async function incrementUsageCount(id) {\n    const collection = await (0,_mongodb__WEBPACK_IMPORTED_MODULE_0__.getCollection)(COLLECTION_NAME);\n    const result = await collection.findOneAndUpdate({\n        _id: new mongodb__WEBPACK_IMPORTED_MODULE_1__.ObjectId(id)\n    }, {\n        $inc: {\n            usageCount: 1\n        }\n    }, {\n        returnDocument: 'after'\n    });\n    return result.value ? mapMongoPrompt(result.value) : null;\n}\n/**\r\n * Search prompts with advanced filtering\r\n * @param {string} query - Search text\r\n * @param {Object} options - Search options\r\n * @returns {Promise<Array>} Array of matching prompts\r\n */ async function searchPrompts(query, options = {}) {\n    const collection = await (0,_mongodb__WEBPACK_IMPORTED_MODULE_0__.getCollection)(COLLECTION_NAME);\n    // Build MongoDB query\n    const filter = {};\n    // Text search if query provided\n    if (query && query.trim() !== '') {\n        filter.$or = [\n            {\n                title: {\n                    $regex: query,\n                    $options: 'i'\n                }\n            },\n            {\n                content: {\n                    $regex: query,\n                    $options: 'i'\n                }\n            },\n            {\n                description: {\n                    $regex: query,\n                    $options: 'i'\n                }\n            },\n            {\n                tags: {\n                    $in: [\n                        query\n                    ]\n                }\n            }\n        ];\n    }\n    // Apply filters\n    if (options.userId) {\n        filter.userId = options.userId;\n    }\n    if (options.teamId) {\n        filter.$or = filter.$or || [];\n        filter.$or.push({\n            teamId: options.teamId\n        }, {\n            visibility: 'team',\n            teamId: options.teamId\n        });\n    }\n    if (options.visibility) {\n        filter.visibility = options.visibility;\n    }\n    if (options.aiPlatform) {\n        filter.aiPlatform = options.aiPlatform;\n    }\n    if (options.minRating) {\n        filter.rating = {\n            $gte: parseFloat(options.minRating)\n        };\n    }\n    if (options.minUsageCount) {\n        filter.usageCount = {\n            $gte: parseInt(options.minUsageCount, 10)\n        };\n    }\n    if (options.tags && options.tags.length > 0) {\n        const tags = Array.isArray(options.tags) ? options.tags : [\n            options.tags\n        ];\n        if (options.tagMatchType === 'any') {\n            filter.tags = {\n                $in: tags\n            };\n        } else {\n            filter.tags = {\n                $all: tags\n            };\n        }\n    }\n    // Sort options\n    const sort = {};\n    if (options.sortBy) {\n        sort[options.sortBy] = options.sortDirection === 'desc' ? -1 : 1;\n    } else {\n        sort.createdAt = -1; // Default sort by newest\n    }\n    const prompts = await collection.find(filter).sort(sort).limit(options.limit || 100).toArray();\n    return prompts.map(mapMongoPrompt);\n}\n/**\r\n * Map MongoDB document to app model (handling _id conversion)\r\n * @param {Object} doc - MongoDB document\r\n * @returns {Object} Mapped prompt object\r\n */ function mapMongoPrompt(doc) {\n    return {\n        id: doc._id.toString(),\n        ...doc,\n        _id: undefined\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uL2xpYi9yZXBvc2l0b3JpZXMvcHJvbXB0UmVwb3NpdG9yeS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQTJDO0FBQ1I7QUFFbkMsTUFBTUUsa0JBQWtCO0FBRXhCOzs7O0NBSUMsR0FDTSxlQUFlQyxjQUFjQyxTQUFTLENBQUMsQ0FBQztJQUM3QyxNQUFNQyxhQUFhLE1BQU1MLHVEQUFhQSxDQUFDRTtJQUN2QyxNQUFNSSxVQUFVLE1BQU1ELFdBQVdFLElBQUksQ0FBQ0gsUUFBUUksT0FBTztJQUNyRCxPQUFPRixRQUFRRyxHQUFHLENBQUNDO0FBQ3JCO0FBRUE7Ozs7Q0FJQyxHQUNNLGVBQWVDLGNBQWNDLEVBQUU7SUFDcEMsTUFBTVAsYUFBYSxNQUFNTCx1REFBYUEsQ0FBQ0U7SUFDdkMsTUFBTVcsU0FBUyxNQUFNUixXQUFXUyxPQUFPLENBQUM7UUFBRUMsS0FBSyxJQUFJZCw2Q0FBUUEsQ0FBQ1c7SUFBSTtJQUNoRSxPQUFPQyxTQUFTSCxlQUFlRyxVQUFVO0FBQzNDO0FBRUE7Ozs7Q0FJQyxHQUNNLGVBQWVHLGFBQWFDLFVBQVU7SUFDM0MsTUFBTVosYUFBYSxNQUFNTCx1REFBYUEsQ0FBQ0U7SUFFdkMsTUFBTWdCLFlBQVk7UUFDaEIsR0FBR0QsVUFBVTtRQUNiRSxXQUFXLElBQUlDO1FBQ2ZDLFdBQVcsSUFBSUQ7UUFDZkUsWUFBWTtRQUNaQyxRQUFRTixXQUFXTSxNQUFNLElBQUk7SUFDL0I7SUFFQSxNQUFNQyxTQUFTLE1BQU1uQixXQUFXb0IsU0FBUyxDQUFDUDtJQUUxQyxPQUFPO1FBQ0xOLElBQUlZLE9BQU9FLFVBQVUsQ0FBQ0MsUUFBUTtRQUM5QixHQUFHVCxTQUFTO0lBQ2Q7QUFDRjtBQUVBOzs7OztDQUtDLEdBQ00sZUFBZVUsYUFBYWhCLEVBQUUsRUFBRUssVUFBVTtJQUMvQyxNQUFNWixhQUFhLE1BQU1MLHVEQUFhQSxDQUFDRTtJQUV2QyxNQUFNMkIsZ0JBQWdCO1FBQ3BCLEdBQUdaLFVBQVU7UUFDYkks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QUFRUSxJQUFJLElBQUlSLFFBQVFRLElBQUksQ0FBQ1ksTUFBTSxHQUFHLEdBQUc7UUFDM0MsTUFBTVosT0FBT2EsTUFBTUMsT0FBTyxDQUFDdEIsUUFBUVEsSUFBSSxJQUFJUixRQUFRUSxJQUFJLEdBQUc7WUFBQ1IsUUFBUVEsSUFBSTtTQUFDO1FBRXhFLElBQUlSLFFBQVF1QixZQUFZLEtBQUssT0FBTztZQUNsQzVELE9BQU82QyxJQUFJLEdBQUc7Z0JBQUVDLEtBQUtEO1lBQUs7UUFDNUIsT0FBTztZQUNMN0MsT0FBTzZDLElBQUksR0FBRztnQkFBRWdCLE1BQU1oQjtZQUFLO1FBQzdCO0lBQ0Y7SUFFQSxlQUFlO0lBQ2YsTUFBTWlCLE9BQU8sQ0FBQztJQUNkLElBQUl6QixRQUFRMEIsTUFBTSxFQUFFO1FBQ2xCRCxJQUFJLENBQUN6QixRQUFRMEIsTUFBTSxDQUFDLEdBQUcxQixRQUFRMkIsYUFBYSxLQUFLLFNBQVMsQ0FBQyxJQUFJO0lBQ2pFLE9BQU87UUFDTEYsS0FBSy9DLFNBQVMsR0FBRyxDQUFDLEdBQUcseUJBQXlCO0lBQ2hEO0lBRUEsTUFBTWIsVUFBVSxNQUFNRCxXQUNuQkUsSUFBSSxDQUFDSCxRQUNMOEQsSUFBSSxDQUFDQSxNQUNMRyxLQUFLLENBQUM1QixRQUFRNEIsS0FBSyxJQUFJLEtBQ3ZCN0QsT0FBTztJQUVWLE9BQU9GLFFBQVFHLEdBQUcsQ0FBQ0M7QUFDckI7QUFFQTs7OztDQUlDLEdBQ0QsU0FBU0EsZUFBZTRELEdBQUc7SUFDekIsT0FBTztRQUNMMUQsSUFBSTBELElBQUl2RCxHQUFHLENBQUNZLFFBQVE7UUFDcEIsR0FBRzJDLEdBQUc7UUFDTnZELEtBQUt3RDtJQUNQO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcYmF1ZGlcXE9uZURyaXZlXFxEZXNrdG9wXFxQcm9tcHRQcm9cXFByb21wdFByb1xcbGliXFxyZXBvc2l0b3JpZXNcXHByb21wdFJlcG9zaXRvcnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0Q29sbGVjdGlvbiB9IGZyb20gJy4uL21vbmdvZGInO1xyXG5pbXBvcnQgeyBPYmplY3RJZCB9IGZyb20gJ21vbmdvZGInO1xyXG5cclxuY29uc3QgQ09MTEVDVElPTl9OQU1FID0gJ3Byb21wdHMnO1xyXG5cclxuLyoqXHJcbiAqIEdldCBhbGwgcHJvbXB0cyB3aXRoIG9wdGlvbmFsIGZpbHRlcmluZ1xyXG4gKiBAcGFyYW0ge09iamVjdH0gZmlsdGVyIC0gT3B0aW9uYWwgZmlsdGVyIGNyaXRlcmlhXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5Pn0gQXJyYXkgb2YgcHJvbXB0c1xyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFsbFByb21wdHMoZmlsdGVyID0ge30pIHtcclxuICBjb25zdCBjb2xsZWN0aW9uID0gYXdhaXQgZ2V0Q29sbGVjdGlvbihDT0xMRUNUSU9OX05BTUUpO1xyXG4gIGNvbnN0IHByb21wdHMgPSBhd2FpdCBjb2xsZWN0aW9uLmZpbmQoZmlsdGVyKS50b0FycmF5KCk7XHJcbiAgcmV0dXJuIHByb21wdHMubWFwKG1hcE1vbmdvUHJvbXB0KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBhIHNpbmdsZSBwcm9tcHQgYnkgSURcclxuICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gUHJvbXB0IElEXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdHxudWxsPn0gUHJvbXB0IG9iamVjdCBvciBudWxsXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UHJvbXB0QnlJZChpZCkge1xyXG4gIGNvbnN0IGNvbGxlY3Rpb24gPSBhd2FpdCBnZXRDb2xsZWN0aW9uKENPTExFQ1RJT05fTkFNRSk7XHJcbiAgY29uc3QgcHJvbXB0ID0gYXdhaXQgY29sbGVjdGlvbi5maW5kT25lKHsgX2lkOiBuZXcgT2JqZWN0SWQoaWQpIH0pO1xyXG4gIHJldHVybiBwcm9tcHQgPyBtYXBNb25nb1Byb21wdChwcm9tcHQpIDogbnVsbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZSBhIG5ldyBwcm9tcHRcclxuICogQHBhcmFtIHtPYmplY3R9IHByb21wdERhdGEgLSBQcm9tcHQgZGF0YVxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBDcmVhdGVkIHByb21wdFxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVByb21wdChwcm9tcHREYXRhKSB7XHJcbiAgY29uc3QgY29sbGVjdGlvbiA9IGF3YWl0IGdldENvbGxlY3Rpb24oQ09MTEVDVElPTl9OQU1FKTtcclxuICBcclxuICBjb25zdCBuZXdQcm9tcHQgPSB7XHJcbiAgICAuLi5wcm9tcHREYXRhLFxyXG4gICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxyXG4gICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLFxyXG4gICAgdXNhZ2VDb3VudDogMCxcclxuICAgIHJhdGluZzogcHJvbXB0RGF0YS5yYXRpbmcgfHwgMFxyXG4gIH07XHJcbiAgXHJcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29sbGVjdGlvbi5pbnNlcnRPbmUobmV3UHJvbXB0KTtcclxuICBcclxuICByZXR1cm4ge1xyXG4gICAgaWQ6IHJlc3VsdC5pbnNlcnRlZElkLnRvU3RyaW5nKCksXHJcbiAgICAuLi5uZXdQcm9tcHRcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogVXBkYXRlIGFuIGV4aXN0aW5nIHByb21wdFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgLSBQcm9tcHQgSURcclxuICogQHBhcmFtIHtPYmplY3R9IHByb21wdERhdGEgLSBVcGRhdGVkIHByb21wdCBkYXRhXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdHxudWxsPn0gVXBkYXRlZCBwcm9tcHQgb3IgbnVsbFxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVByb21wdChpZCwgcHJvbXB0RGF0YSkge1xyXG4gIGNvbnN0IGNvbGxlY3Rpb24gPSBhd2FpdCBnZXRDb2xsZWN0aW9uKENPTExFQ1RJT05fTkFNRSk7XHJcbiAgXHJcbiAgY29uc3QgdXBkYXRlZFByb21wdCA9IHtcclxuICAgIC4uLnByb21wdERhdGEsXHJcbiAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKClcclxuICB9O1xyXG4gIFxyXG4gIC8vIERvbid0IG92ZXJyaWRlIHRoZXNlIGZpZWxkcyBpZiBub3QgZXhwbGljaXRseSBwcm92aWRlZFxyXG4gIGRlbGV0ZSB1cGRhdGVkUHJvbXB0Ll9pZDtcclxuICBkZWxldGUgdXBkYXRlZFByb21wdC5pZDtcclxuICBkZWxldGUgdXBkYXRlZFByb21wdC5jcmVhdGVkQXQ7XHJcbiAgXHJcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29sbGVjdGlvbi5maW5kT25lQW5kVXBkYXRlKFxyXG4gICAgeyBfaWQ6IG5ldyBPYmplY3RJZChpZCkgfSxcclxuICAgIHsgJHNldDogdXBkYXRlZFByb21wdCB9LFxyXG4gICAgeyByZXR1cm5Eb2N1bWVudDogJ2FmdGVyJyB9XHJcbiAgKTtcclxuICBcclxuICByZXR1cm4gcmVzdWx0LnZhbHVlID8gbWFwTW9uZ29Qcm9tcHQocmVzdWx0LnZhbHVlKSA6IG51bGw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZWxldGUgYSBwcm9tcHRcclxuICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gUHJvbXB0IElEXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSBTdWNjZXNzIGZsYWdcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWxldGVQcm9tcHQoaWQpIHtcclxuICBjb25zdCBjb2xsZWN0aW9uID0gYXdhaXQgZ2V0Q29sbGVjdGlvbihDT0xMRUNUSU9OX05BTUUpO1xyXG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbGxlY3Rpb24uZGVsZXRlT25lKHsgX2lkOiBuZXcgT2JqZWN0SWQoaWQpIH0pO1xyXG4gIHJldHVybiByZXN1bHQuZGVsZXRlZENvdW50ID09PSAxO1xyXG59XHJcblxyXG4vKipcclxuICogSW5jcmVtZW50IHByb21wdCB1c2FnZSBjb3VudFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgLSBQcm9tcHQgSURcclxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0fG51bGw+fSBVcGRhdGVkIHByb21wdCBvciBudWxsXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW5jcmVtZW50VXNhZ2VDb3VudChpZCkge1xyXG4gIGNvbnN0IGNvbGxlY3Rpb24gPSBhd2FpdCBnZXRDb2xsZWN0aW9uKENPTExFQ1RJT05fTkFNRSk7XHJcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29sbGVjdGlvbi5maW5kT25lQW5kVXBkYXRlKFxyXG4gICAgeyBfaWQ6IG5ldyBPYmplY3RJZChpZCkgfSxcclxuICAgIHsgJGluYzogeyB1c2FnZUNvdW50OiAxIH0gfSxcclxuICAgIHsgcmV0dXJuRG9jdW1lbnQ6ICdhZnRlcicgfVxyXG4gICk7XHJcbiAgXHJcbiAgcmV0dXJuIHJlc3VsdC52YWx1ZSA/IG1hcE1vbmdvUHJvbXB0KHJlc3VsdC52YWx1ZSkgOiBudWxsO1xyXG59XHJcblxyXG4vKipcclxuICogU2VhcmNoIHByb21wdHMgd2l0aCBhZHZhbmNlZCBmaWx0ZXJpbmdcclxuICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5IC0gU2VhcmNoIHRleHRcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBTZWFyY2ggb3B0aW9uc1xyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheT59IEFycmF5IG9mIG1hdGNoaW5nIHByb21wdHNcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZWFyY2hQcm9tcHRzKHF1ZXJ5LCBvcHRpb25zID0ge30pIHtcclxuICBjb25zdCBjb2xsZWN0aW9uID0gYXdhaXQgZ2V0Q29sbGVjdGlvbihDT0xMRUNUSU9OX05BTUUpO1xyXG4gIFxyXG4gIC8vIEJ1aWxkIE1vbmdvREIgcXVlcnlcclxuICBjb25zdCBmaWx0ZXIgPSB7fTtcclxuICBcclxuICAvLyBUZXh0IHNlYXJjaCBpZiBxdWVyeSBwcm92aWRlZFxyXG4gIGlmIChxdWVyeSAmJiBxdWVyeS50cmltKCkgIT09ICcnKSB7XHJcbiAgICBmaWx0ZXIuJG9yID0gW1xyXG4gICAgICB7IHRpdGxlOiB7ICRyZWdleDogcXVlcnksICRvcHRpb25zOiAnaScgfSB9LFxyXG4gICAgICB7IGNvbnRlbnQ6IHsgJHJlZ2V4OiBxdWVyeSwgJG9wdGlvbnM6ICdpJyB9IH0sXHJcbiAgICAgIHsgZGVzY3JpcHRpb246IHsgJHJlZ2V4OiBxdWVyeSwgJG9wdGlvbnM6ICdpJyB9IH0sXHJcbiAgICAgIHsgdGFnczogeyAkaW46IFtxdWVyeV0gfSB9XHJcbiAgICBdO1xyXG4gIH1cclxuICBcclxuICAvLyBBcHBseSBmaWx0ZXJzXHJcbiAgaWYgKG9wdGlvbnMudXNlcklkKSB7XHJcbiAgICBmaWx0ZXIudXNlcklkID0gb3B0aW9ucy51c2VySWQ7XHJcbiAgfVxyXG4gIFxyXG4gIGlmIChvcHRpb25zLnRlYW1JZCkge1xyXG4gICAgZmlsdGVyLiRvciA9IGZpbHRlci4kb3IgfHwgW107XHJcbiAgICBmaWx0ZXIuJG9yLnB1c2goXHJcbiAgICAgIHsgdGVhbUlkOiBvcHRpb25zLnRlYW1JZCB9LFxyXG4gICAgICB7IHZpc2liaWxpdHk6ICd0ZWFtJywgdGVhbUlkOiBvcHRpb25zLnRlYW1JZCB9XHJcbiAgICApO1xyXG4gIH1cclxuICBcclxuICBpZiAob3B0aW9ucy52aXNpYmlsaXR5KSB7XHJcbiAgICBmaWx0ZXIudmlzaWJpbGl0eSA9IG9wdGlvbnMudmlzaWJpbGl0eTtcclxuICB9XHJcbiAgXHJcbiAgaWYgKG9wdGlvbnMuYWlQbGF0Zm9ybSkge1xyXG4gICAgZmlsdGVyLmFpUGxhdGZvcm0gPSBvcHRpb25zLmFpUGxhdGZvcm07XHJcbiAgfVxyXG4gIFxyXG4gIGlmIChvcHRpb25zLm1pblJhdGluZykge1xyXG4gICAgZmlsdGVyLnJhdGluZyA9IHsgJGd0ZTogcGFyc2VGbG9hdChvcHRpb25zLm1pblJhdGluZykgfTtcclxuICB9XHJcbiAgXHJcbiAgaWYgKG9wdGlvbnMubWluVXNhZ2VDb3VudCkge1xyXG4gICAgZmlsdGVyLnVzYWdlQ291bnQgPSB7ICRndGU6IHBhcnNlSW50KG9wdGlvbnMubWluVXNhZ2VDb3VudCwgMTApIH07XHJcbiAgfVxyXG4gIFxyXG4gIGlmIChvcHRpb25zLnRhZ3MgJiYgb3B0aW9ucy50YWdzLmxlbmd0aCA+IDApIHtcclxuICAgIGNvbnN0IHRhZ3MgPSBBcnJheS5pc0FycmF5KG9wdGlvbnMudGFncykgPyBvcHRpb25zLnRhZ3MgOiBbb3B0aW9ucy50YWdzXTtcclxuICAgIFxyXG4gICAgaWYgKG9wdGlvbnMudGFnTWF0Y2hUeXBlID09PSAnYW55Jykge1xyXG4gICAgICBmaWx0ZXIudGFncyA9IHsgJGluOiB0YWdzIH07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBmaWx0ZXIudGFncyA9IHsgJGFsbDogdGFncyB9O1xyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICAvLyBTb3J0IG9wdGlvbnNcclxuICBjb25zdCBzb3J0ID0ge307XHJcbiAgaWYgKG9wdGlvbnMuc29ydEJ5KSB7XHJcbiAgICBzb3J0W29wdGlvbnMuc29ydEJ5XSA9IG9wdGlvbnMuc29ydERpcmVjdGlvbiA9PT0gJ2Rlc2MnID8gLTEgOiAxO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBzb3J0LmNyZWF0ZWRBdCA9IC0xOyAvLyBEZWZhdWx0IHNvcnQgYnkgbmV3ZXN0XHJcbiAgfVxyXG4gIFxyXG4gIGNvbnN0IHByb21wdHMgPSBhd2FpdCBjb2xsZWN0aW9uXHJcbiAgICAuZmluZChmaWx0ZXIpXHJcbiAgICAuc29ydChzb3J0KVxyXG4gICAgLmxpbWl0KG9wdGlvbnMubGltaXQgfHwgMTAwKVxyXG4gICAgLnRvQXJyYXkoKTtcclxuICBcclxuICByZXR1cm4gcHJvbXB0cy5tYXAobWFwTW9uZ29Qcm9tcHQpO1xyXG59XHJcblxyXG4vKipcclxuICogTWFwIE1vbmdvREIgZG9jdW1lbnQgdG8gYXBwIG1vZGVsIChoYW5kbGluZyBfaWQgY29udmVyc2lvbilcclxuICogQHBhcmFtIHtPYmplY3R9IGRvYyAtIE1vbmdvREIgZG9jdW1lbnRcclxuICogQHJldHVybnMge09iamVjdH0gTWFwcGVkIHByb21wdCBvYmplY3RcclxuICovXHJcbmZ1bmN0aW9uIG1hcE1vbmdvUHJvbXB0KGRvYykge1xyXG4gIHJldHVybiB7XHJcbiAgICBpZDogZG9jLl9pZC50b1N0cmluZygpLFxyXG4gICAgLi4uZG9jLFxyXG4gICAgX2lkOiB1bmRlZmluZWRcclxuICB9O1xyXG59ICJdLCJuYW1lcyI6WyJnZXRDb2xsZWN0aW9uIiwiT2JqZWN0SWQiLCJDT0xMRUNUSU9OX05BTUUiLCJnZXRBbGxQcm9tcHRzIiwiZmlsdGVyIiwiY29sbGVjdGlvbiIsInByb21wdHMiLCJmaW5kIiwidG9BcnJheSIsIm1hcCIsIm1hcE1vbmdvUHJvbXB0IiwiZ2V0UHJvbXB0QnlJZCIsImlkIiwicHJvbXB0IiwiZmluZE9uZSIsIl9pZCIsImNyZWF0ZVByb21wdCIsInByb21wdERhdGEiLCJuZXdQcm9tcHQiLCJjcmVhdGVkQXQiLCJEYXRlIiwidXBkYXRlZEF0IiwidXNhZ2VDb3VudCIsInJhdGluZyIsInJlc3VsdCIsImluc2VydE9uZSIsImluc2VydGVkSWQiLCJ0b1N0cmluZyIsInVwZGF0ZVByb21wdCIsInVwZGF0ZWRQcm9tcHQiLCJmaW5kT25lQW5kVXBkYXRlIiwiJHNldCIsInJldHVybkRvY3VtZW50IiwidmFsdWUiLCJkZWxldGVQcm9tcHQiLCJkZWxldGVPbmUiLCJkZWxldGVkQ291bnQiLCJpbmNyZW1lbnRVc2FnZUNvdW50IiwiJGluYyIsInNlYXJjaFByb21wdHMiLCJxdWVyeSIsIm9wdGlvbnMiLCJ0cmltIiwiJG9yIiwidGl0bGUiLCIkcmVnZXgiLCIkb3B0aW9ucyIsImNvbnRlbnQiLCJkZXNjcmlwdGlvbiIsInRhZ3MiLCIkaW4iLCJ1c2VySWQiLCJ0ZWFtSWQiLCJwdXNoIiwidmlzaWJpbGl0eSIsImFpUGxhdGZvcm0iLCJtaW5SYXRpbmciLCIkZ3RlIiwicGFyc2VGbG9hdCIsIm1pblVzYWdlQ291bnQiLCJwYXJzZUludCIsImxlbmd0aCIsIkFycmF5IiwiaXNBcnJheSIsInRhZ01hdGNoVHlwZSIsIiRhbGwiLCJzb3J0Iiwic29ydEJ5Iiwic29ydERpcmVjdGlvbiIsImxpbWl0IiwiZG9jIiwidW5kZWZpbmVkIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api-node)/./lib/repositories/promptRepository.js\n");

/***/ }),

/***/ "(api-node)/./models/prompt.js":
/*!**************************!*\
  !*** ./models/prompt.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SUPPORTED_AI_PLATFORMS: () => (/* binding */ SUPPORTED_AI_PLATFORMS),\n/* harmony export */   promptModel: () => (/* binding */ promptModel),\n/* harmony export */   validatePrompt: () => (/* binding */ validatePrompt)\n/* harmony export */ });\n// Prompt model structure\n// Define supported AI platforms\nconst SUPPORTED_AI_PLATFORMS = [\n    'ChatGPT',\n    'Claude',\n    'Gemini',\n    'MidJourney',\n    'DALL-E',\n    'Other' // Allow a generic 'Other' category\n];\nconst promptModel = {\n    id: Number,\n    title: String,\n    content: String,\n    description: String,\n    tags: Array,\n    aiPlatform: String,\n    compatiblePlatforms: Array,\n    rating: Number,\n    usageCount: Number,\n    successRate: Number,\n    visibility: String,\n    userId: Number,\n    createdBy: String,\n    teamId: Number,\n    createdAt: String,\n    updatedAt: String\n};\n// Validate prompt data\nconst validatePrompt = (data)=>{\n    const errors = {};\n    // Required fields\n    if (!data.title) {\n        errors.title = 'Title is required';\n    } else if (data.title.length < 3) {\n        errors.title = 'Title must be at least 3 characters';\n    } else if (data.title.length > 100) {\n        errors.title = 'Title must be less than 100 characters';\n    }\n    if (!data.content) {\n        errors.content = 'Content is required';\n    } else if (data.content.length < 10) {\n        errors.content = 'Content must be at least 10 characters';\n    }\n    // Optional description\n    if (data.description && data.description.length > 500) {\n        errors.description = 'Description must be less than 500 characters';\n    }\n    // Tags validation\n    if (data.tags) {\n        if (!Array.isArray(data.tags)) {\n            errors.tags = 'Tags must be an array';\n        } else {\n            for(let i = 0; i < data.tags.length; i++){\n                const tag = data.tags[i];\n                if (typeof tag !== 'string') {\n                    errors.tags = 'All tags must be strings';\n                    break;\n                }\n                if (tag.length < 1) {\n                    errors.tags = 'Tags cannot be empty';\n                    break;\n                }\n                if (tag.length > 20) {\n                    errors.tags = 'Tags must be less than 20 characters';\n                    break;\n                }\n            }\n        }\n    }\n    // AI Platform validation (Primary)\n    if (data.aiPlatform) {\n        if (typeof data.aiPlatform !== 'string') {\n            errors.aiPlatform = 'AI Platform must be a string';\n        } else if (!SUPPORTED_AI_PLATFORMS.includes(data.aiPlatform)) {\n            errors.aiPlatform = `AI Platform must be one of: ${SUPPORTED_AI_PLATFORMS.join(', ')}`;\n        }\n    } else {\n    // Make primary platform required, or default it? For now, let's require it if provided.\n    // If it's truly optional, remove this else block. Assuming it might be optional for now.\n    }\n    // Compatible Platforms validation (Optional)\n    if (data.compatiblePlatforms) {\n        if (!Array.isArray(data.compatiblePlatforms)) {\n            errors.compatiblePlatforms = 'Compatible Platforms must be an array';\n        } else {\n            for(let i = 0; i < data.compatiblePlatforms.length; i++){\n                const platform = data.compatiblePlatforms[i];\n                if (typeof platform !== 'string') {\n                    errors.compatiblePlatforms = 'All compatible platforms must be strings';\n                    break;\n                }\n                if (!SUPPORTED_AI_PLATFORMS.includes(platform)) {\n                    errors.compatiblePlatforms = `Compatible platform \"${platform}\" is not supported. Must be one of: ${SUPPORTED_AI_PLATFORMS.join(', ')}`;\n                    break;\n                }\n            }\n            // Ensure compatible platforms don't duplicate the primary platform if both are set\n            if (data.aiPlatform && data.compatiblePlatforms.includes(data.aiPlatform)) {\n                errors.compatiblePlatforms = 'Compatible Platforms should not include the primary AI Platform.';\n            }\n        }\n    }\n    // Rating validation (1-5)\n    if (data.rating !== undefined) {\n        if (typeof data.rating !== 'number') {\n            errors.rating = 'Rating must be a number';\n        } else if (data.rating < 1 || data.rating > 5) {\n            errors.rating = 'Rating must be between 1 and 5';\n        }\n    }\n    // Usage count validation\n    if (data.usageCount !== undefined && (typeof data.usageCount !== 'number' || data.usageCount < 0)) {\n        errors.usageCount = 'Usage count must be a non-negative number';\n    }\n    // Success rate validation (0-100)\n    if (data.successRate !== undefined) {\n        if (typeof data.successRate !== 'number') {\n            errors.successRate = 'Success rate must be a number';\n        } else if (data.successRate < 0 || data.successRate > 100) {\n            errors.successRate = 'Success rate must be between 0 and 100';\n        }\n    }\n    // Visibility validation\n    if (data.visibility) {\n        const validVisibilities = [\n            'public',\n            'private',\n            'team'\n        ];\n        if (!validVisibilities.includes(data.visibility)) {\n            errors.visibility = 'Visibility must be one of: public, private, team';\n        }\n        // If visibility is 'team', teamId must be provided\n        if (data.visibility === 'team' && !data.teamId) {\n            errors.teamId = 'Team ID is required when visibility is set to team';\n        }\n    }\n    return {\n        isValid: Object.keys(errors).length === 0,\n        errors\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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R0FBRyxLQUFLUSxLQUFLUixXQUFXLEdBQUcsS0FBSztZQUN6RFMsT0FBT1QsV0FBVyxHQUFHO1FBQ3ZCO0lBQ0Y7SUFFQSx3QkFBd0I7SUFDeEIsSUFBSVEsS0FBS1AsVUFBVSxFQUFFO1FBQ25CLE1BQU1pQixvQkFBb0I7WUFBQztZQUFVO1lBQVc7U0FBTztRQUN2RCxJQUFJLENBQUNBLGtCQUFrQkosUUFBUSxDQUFDTixLQUFLUCxVQUFVLEdBQUc7WUFDaERRLE9BQU9SLFVBQVUsR0FBRztRQUN0QjtRQUVBLG1EQUFtRDtRQUNuRCxJQUFJTyxLQUFLUCxVQUFVLEtBQUssVUFBVSxDQUFDTyxLQUFLSixNQUFNLEVBQUU7WUFDOUNLLE9BQU9MLE1BQU0sR0FBRztRQUNsQjtJQUNGO0lBRUEsT0FBTztRQUNMZSxTQUFTQyxPQUFPQyxJQUFJLENBQUNaLFFBQVFDLE1BQU0sS0FBSztRQUN4Q0Q7SUFDRjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcYmF1ZGlcXE9uZURyaXZlXFxEZXNrdG9wXFxQcm9tcHRQcm9cXFByb21wdFByb1xcbW9kZWxzXFxwcm9tcHQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gUHJvbXB0IG1vZGVsIHN0cnVjdHVyZVxuXG4vLyBEZWZpbmUgc3VwcG9ydGVkIEFJIHBsYXRmb3Jtc1xuZXhwb3J0IGNvbnN0IFNVUFBPUlRFRF9BSV9QTEFURk9STVMgPSBbXG4gICdDaGF0R1BUJywgXG4gICdDbGF1ZGUnLCBcbiAgJ0dlbWluaScsIFxuICAnTWlkSm91cm5leScsIFxuICAnREFMTC1FJyxcbiAgJ090aGVyJyAvLyBBbGxvdyBhIGdlbmVyaWMgJ090aGVyJyBjYXRlZ29yeVxuXTtcblxuZXhwb3J0IGNvbnN0IHByb21wdE1vZGVsID0ge1xuICBpZDogTnVtYmVyLFxuICB0aXRsZTogU3RyaW5nLFxuICBjb250ZW50OiBTdHJpbmcsXG4gIGRlc2NyaXB0aW9uOiBTdHJpbmcsIC8vIEJyaWVmIGRlc2NyaXB0aW9uIG9mIHdoYXQgdGhlIHByb21wdCBkb2VzXG4gIHRhZ3M6IEFycmF5LCAvLyBvZiBzdHJpbmdzXG4gIGFpUGxhdGZvcm06IFN0cmluZywgLy8gUHJpbWFyeSBwbGF0Zm9ybSwgZS5nLiwgJ0NoYXRHUFQnLCAnQ2xhdWRlJywgZXRjLlxuICBjb21wYXRpYmxlUGxhdGZvcm1zOiBBcnJheSwgLy8gT3RoZXIgcGxhdGZvcm1zIHRoaXMgcHJvbXB0IG1pZ2h0IHdvcmsgb24gKG9wdGlvbmFsKVxuICByYXRpbmc6IE51bWJlciwgLy8gMS01IHJhdGluZ1xuICB1c2FnZUNvdW50OiBOdW1iZXIsIC8vIEhvdyBtYW55IHRpbWVzIHRoZSBwcm9tcHQgaGFzIGJlZW4gdXNlZFxuICBzdWNjZXNzUmF0ZTogTnVtYmVyLCAvLyBQZXJjZW50YWdlIG9mIHN1Y2Nlc3NmdWwgdXNlcyAoMC0xMDApXG4gIHZpc2liaWxpdHk6IFN0cmluZywgLy8gJ3B1YmxpYycsICdwcml2YXRlJywgJ3RlYW0nXG4gIHVzZXJJZDogTnVtYmVyLCAvLyBJRCBvZiB0aGUgdXNlciB3aG8gY3JlYXRlZCB0aGUgcHJvbXB0XG4gIGNyZWF0ZWRCeTogU3RyaW5nLCAvLyBOYW1lIG9mIHRoZSB1c2VyIHdobyBjcmVhdGVkIHRoZSBwcm9tcHRcbiAgdGVhbUlkOiBOdW1iZXIsIC8vIElEIG9mIHRoZSB0ZWFtIGlmIHNoYXJlZCB3aXRoIGEgdGVhbSAob3B0aW9uYWwpXG4gIGNyZWF0ZWRBdDogU3RyaW5nLCAvLyBJU08gZGF0ZSBzdHJpbmdcbiAgdXBkYXRlZEF0OiBTdHJpbmcsIC8vIElTTyBkYXRlIHN0cmluZ1xufTtcblxuLy8gVmFsaWRhdGUgcHJvbXB0IGRhdGFcbmV4cG9ydCBjb25zdCB2YWxpZGF0ZVByb21wdCA9IChkYXRhKSA9PiB7XG4gIGNvbnN0IGVycm9ycyA9IHt9O1xuICBcbiAgLy8gUmVxdWlyZWQgZmllbGRzXG4gIGlmICghZGF0YS50aXRsZSkge1xuICAgIGVycm9ycy50aXRsZSA9ICdUaXRsZSBpcyByZXF1aXJlZCc7XG4gIH0gZWxzZSBpZiAoZGF0YS50aXRsZS5sZW5ndGggPCAzKSB7XG4gICAgZXJyb3JzLnRpdGxlID0gJ1RpdGxlIG11c3QgYmUgYXQgbGVhc3QgMyBjaGFyYWN0ZXJzJztcbiAgfSBlbHNlIGlmIChkYXRhLnRpdGxlLmxlbmd0aCA+IDEwMCkge1xuICAgIGVycm9ycy50aXRsZSA9ICdUaXRsZSBtdXN0IGJlIGxlc3MgdGhhbiAxMDAgY2hhcmFjdGVycyc7XG4gIH1cbiAgXG4gIGlmICghZGF0YS5jb250ZW50KSB7XG4gICAgZXJyb3JzLmNvbnRlbnQgPSAnQ29udGVudCBpcyByZXF1aXJlZCc7XG4gIH0gZWxzZSBpZiAoZGF0YS5jb250ZW50Lmxlbmd0aCA8IDEwKSB7XG4gICAgZXJyb3JzLmNvbnRlbnQgPSAnQ29udGVudCBtdXN0IGJlIGF0IGxlYXN0IDEwIGNoYXJhY3RlcnMnO1xuICB9XG4gIFxuICAvLyBPcHRpb25hbCBkZXNjcmlwdGlvblxuICBpZiAoZGF0YS5kZXNjcmlwdGlvbiAmJiBkYXRhLmRlc2NyaXB0aW9uLmxlbmd0aCA+IDUwMCkge1xuICAgIGVycm9ycy5kZXNjcmlwdGlvbiA9ICdEZXNjcmlwdGlvbiBtdXN0IGJlIGxlc3MgdGhhbiA1MDAgY2hhcmFjdGVycyc7XG4gIH1cbiAgXG4gIC8vIFRhZ3MgdmFsaWRhdGlvblxuICBpZiAoZGF0YS50YWdzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEudGFncykpIHtcbiAgICAgIGVycm9ycy50YWdzID0gJ1RhZ3MgbXVzdCBiZSBhbiBhcnJheSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS50YWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHRhZyA9IGRhdGEudGFnc1tpXTtcbiAgICAgICAgaWYgKHR5cGVvZiB0YWcgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgZXJyb3JzLnRhZ3MgPSAnQWxsIHRhZ3MgbXVzdCBiZSBzdHJpbmdzJztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFnLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICBlcnJvcnMudGFncyA9ICdUYWdzIGNhbm5vdCBiZSBlbXB0eSc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZy5sZW5ndGggPiAyMCkge1xuICAgICAgICAgIGVycm9ycy50YWdzID0gJ1RhZ3MgbXVzdCBiZSBsZXNzIHRoYW4gMjAgY2hhcmFjdGVycyc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIC8vIEFJIFBsYXRmb3JtIHZhbGlkYXRpb24gKFByaW1hcnkpXG4gIGlmIChkYXRhLmFpUGxhdGZvcm0pIHtcbiAgICAgIGlmICh0eXBlb2YgZGF0YS5haVBsYXRmb3JtICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIGVycm9ycy5haVBsYXRmb3JtID0gJ0FJIFBsYXRmb3JtIG11c3QgYmUgYSBzdHJpbmcnO1xuICAgICAgfSBlbHNlIGlmICghU1VQUE9SVEVEX0FJX1BMQVRGT1JNUy5pbmNsdWRlcyhkYXRhLmFpUGxhdGZvcm0pKSB7XG4gICAgICAgICAgZXJyb3JzLmFpUGxhdGZvcm0gPSBgQUkgUGxhdGZvcm0gbXVzdCBiZSBvbmUgb2Y6ICR7U1VQUE9SVEVEX0FJX1BMQVRGT1JNUy5qb2luKCcsICcpfWA7XG4gICAgICB9XG4gIH0gZWxzZSB7XG4gICAgICAvLyBNYWtlIHByaW1hcnkgcGxhdGZvcm0gcmVxdWlyZWQsIG9yIGRlZmF1bHQgaXQ/IEZvciBub3csIGxldCdzIHJlcXVpcmUgaXQgaWYgcHJvdmlkZWQuXG4gICAgICAvLyBJZiBpdCdzIHRydWx5IG9wdGlvbmFsLCByZW1vdmUgdGhpcyBlbHNlIGJsb2NrLiBBc3N1bWluZyBpdCBtaWdodCBiZSBvcHRpb25hbCBmb3Igbm93LlxuICB9XG5cbiAgLy8gQ29tcGF0aWJsZSBQbGF0Zm9ybXMgdmFsaWRhdGlvbiAoT3B0aW9uYWwpXG4gIGlmIChkYXRhLmNvbXBhdGlibGVQbGF0Zm9ybXMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YS5jb21wYXRpYmxlUGxhdGZvcm1zKSkge1xuICAgICAgZXJyb3JzLmNvbXBhdGlibGVQbGF0Zm9ybXMgPSAnQ29tcGF0aWJsZSBQbGF0Zm9ybXMgbXVzdCBiZSBhbiBhcnJheSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5jb21wYXRpYmxlUGxhdGZvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBsYXRmb3JtID0gZGF0YS5jb21wYXRpYmxlUGxhdGZvcm1zW2ldO1xuICAgICAgICBpZiAodHlwZW9mIHBsYXRmb3JtICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIGVycm9ycy5jb21wYXRpYmxlUGxhdGZvcm1zID0gJ0FsbCBjb21wYXRpYmxlIHBsYXRmb3JtcyBtdXN0IGJlIHN0cmluZ3MnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICghU1VQUE9SVEVEX0FJX1BMQVRGT1JNUy5pbmNsdWRlcyhwbGF0Zm9ybSkpIHtcbiAgICAgICAgICBlcnJvcnMuY29tcGF0aWJsZVBsYXRmb3JtcyA9IGBDb21wYXRpYmxlIHBsYXRmb3JtIFwiJHtwbGF0Zm9ybX1cIiBpcyBub3Qgc3VwcG9ydGVkLiBNdXN0IGJlIG9uZSBvZjogJHtTVVBQT1JURURfQUlfUExBVEZPUk1TLmpvaW4oJywgJyl9YDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRW5zdXJlIGNvbXBhdGlibGUgcGxhdGZvcm1zIGRvbid0IGR1cGxpY2F0ZSB0aGUgcHJpbWFyeSBwbGF0Zm9ybSBpZiBib3RoIGFyZSBzZXRcbiAgICAgIGlmIChkYXRhLmFpUGxhdGZvcm0gJiYgZGF0YS5jb21wYXRpYmxlUGxhdGZvcm1zLmluY2x1ZGVzKGRhdGEuYWlQbGF0Zm9ybSkpIHtcbiAgICAgICAgICBlcnJvcnMuY29tcGF0aWJsZVBsYXRmb3JtcyA9ICdDb21wYXRpYmxlIFBsYXRmb3JtcyBzaG91bGQgbm90IGluY2x1ZGUgdGhlIHByaW1hcnkgQUkgUGxhdGZvcm0uJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIC8vIFJhdGluZyB2YWxpZGF0aW9uICgxLTUpXG4gIGlmIChkYXRhLnJhdGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhLnJhdGluZyAhPT0gJ251bWJlcicpIHtcbiAgICAgIGVycm9ycy5yYXRpbmcgPSAnUmF0aW5nIG11c3QgYmUgYSBudW1iZXInO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5yYXRpbmcgPCAxIHx8IGRhdGEucmF0aW5nID4gNSkge1xuICAgICAgZXJyb3JzLnJhdGluZyA9ICdSYXRpbmcgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDUnO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gVXNhZ2UgY291bnQgdmFsaWRhdGlvblxuICBpZiAoZGF0YS51c2FnZUNvdW50ICE9PSB1bmRlZmluZWQgJiYgKHR5cGVvZiBkYXRhLnVzYWdlQ291bnQgIT09ICdudW1iZXInIHx8IGRhdGEudXNhZ2VDb3VudCA8IDApKSB7XG4gICAgZXJyb3JzLnVzYWdlQ291bnQgPSAnVXNhZ2UgY291bnQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXInO1xuICB9XG4gIFxuICAvLyBTdWNjZXNzIHJhdGUgdmFsaWRhdGlvbiAoMC0xMDApXG4gIGlmIChkYXRhLnN1Y2Nlc3NSYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEuc3VjY2Vzc1JhdGUgIT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcnMuc3VjY2Vzc1JhdGUgPSAnU3VjY2VzcyByYXRlIG11c3QgYmUgYSBudW1iZXInO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5zdWNjZXNzUmF0ZSA8IDAgfHwgZGF0YS5zdWNjZXNzUmF0ZSA+IDEwMCkge1xuICAgICAgZXJyb3JzLnN1Y2Nlc3NSYXRlID0gJ1N1Y2Nlc3MgcmF0ZSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwJztcbiAgICB9XG4gIH1cbiAgXG4gIC8vIFZpc2liaWxpdHkgdmFsaWRhdGlvblxuICBpZiAoZGF0YS52aXNpYmlsaXR5KSB7XG4gICAgY29uc3QgdmFsaWRWaXNpYmlsaXRpZXMgPSBbJ3B1YmxpYycsICdwcml2YXRlJywgJ3RlYW0nXTtcbiAgICBpZiAoIXZhbGlkVmlzaWJpbGl0aWVzLmluY2x1ZGVzKGRhdGEudmlzaWJpbGl0eSkpIHtcbiAgICAgIGVycm9ycy52aXNpYmlsaXR5ID0gJ1Zpc2liaWxpdHkgbXVzdCBiZSBvbmUgb2Y6IHB1YmxpYywgcHJpdmF0ZSwgdGVhbSc7XG4gICAgfVxuICAgIFxuICAgIC8vIElmIHZpc2liaWxpdHkgaXMgJ3RlYW0nLCB0ZWFtSWQgbXVzdCBiZSBwcm92aWRlZFxuICAgIGlmIChkYXRhLnZpc2liaWxpdHkgPT09ICd0ZWFtJyAmJiAhZGF0YS50ZWFtSWQpIHtcbiAgICAgIGVycm9ycy50ZWFtSWQgPSAnVGVhbSBJRCBpcyByZXF1aXJlZCB3aGVuIHZpc2liaWxpdHkgaXMgc2V0IHRvIHRlYW0nO1xuICAgIH1cbiAgfVxuICBcbiAgcmV0dXJuIHtcbiAgICBpc1ZhbGlkOiBPYmplY3Qua2V5cyhlcnJvcnMpLmxlbmd0aCA9PT0gMCxcbiAgICBlcnJvcnNcbiAgfTtcbn07XG4iXSwibmFtZXMiOlsiU1VQUE9SVEVEX0FJX1BMQVRGT1JNUyIsInByb21wdE1vZGVsIiwiaWQiLCJOdW1iZXIiLCJ0aXRsZSIsIlN0cmluZyIsImNvbnRlbnQiLCJkZXNjcmlwdGlvbiIsInRhZ3MiLCJBcnJheSIsImFpUGxhdGZvcm0iLCJjb21wYXRpYmxlUGxhdGZvcm1zIiwicmF0aW5nIiwidXNhZ2VDb3VudCIsInN1Y2Nlc3NSYXRlIiwidmlzaWJpbGl0eSIsInVzZXJJZCIsImNyZWF0ZWRCeSIsInRlYW1JZCIsImNyZWF0ZWRBdCIsInVwZGF0ZWRBdCIsInZhbGlkYXRlUHJvbXB0IiwiZGF0YSIsImVycm9ycyIsImxlbmd0aCIsImlzQXJyYXkiLCJpIiwidGFnIiwiaW5jbHVkZXMiLCJqb2luIiwicGxhdGZvcm0iLCJ1bmRlZmluZWQiLCJ2YWxpZFZpc2liaWxpdGllcyIsImlzVmFsaWQiLCJPYmplY3QiLCJrZXlzIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api-node)/./models/prompt.js\n");

/***/ }),

/***/ "(api-node)/./models/team.js":
/*!************************!*\
  !*** ./models/team.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getMemberRole: () => (/* binding */ getMemberRole),\n/* harmony export */   isTeamAdmin: () => (/* binding */ isTeamAdmin),\n/* harmony export */   isTeamMember: () => (/* binding */ isTeamMember),\n/* harmony export */   sanitizeTeam: () => (/* binding */ sanitizeTeam),\n/* harmony export */   teamModel: () => (/* binding */ teamModel),\n/* harmony export */   validateTeam: () => (/* binding */ validateTeam)\n/* harmony export */ });\n/**\n * Team data model and validation functions\n */ /**\n * Team model schema\n * @typedef {Object} TeamModel\n * @property {string} id - Unique identifier\n * @property {string} name - Team name\n * @property {string} description - Team description\n * @property {string} userId - ID of the team creator/owner\n * @property {Array<TeamMember>} members - Array of team members\n * @property {string} createdAt - Creation timestamp\n * @property {string} updatedAt - Last update timestamp\n */ /**\n * Team member schema\n * @typedef {Object} TeamMember\n * @property {string} userId - User ID\n * @property {string} role - Member role (owner, admin, member)\n * @property {string} joinedAt - Timestamp when member joined\n */ /**\n * Team model definition\n */ const teamModel = {\n    id: '',\n    name: '',\n    description: '',\n    userId: '',\n    members: [],\n    createdAt: '',\n    updatedAt: ''\n};\n/**\n * Validate team data\n * @param {Object} data - Team data to validate\n * @returns {Object} Validation result with errors if any\n */ const validateTeam = (data, isUpdate = false)=>{\n    const errors = {};\n    // Name is required unless this is an update\n    if (!isUpdate || data.name !== undefined) {\n        if (!data.name || data.name.trim() === '') {\n            errors.name = 'Team name is required';\n        } else if (data.name.length > 100) {\n            errors.name = 'Team name must be less than 100 characters';\n        }\n    }\n    // Description length check if provided\n    if (data.description && data.description.length > 500) {\n        errors.description = 'Team description must be less than 500 characters';\n    }\n    // Creator required for new teams\n    if (!isUpdate && !data.userId) {\n        errors.userId = 'Creator ID is required';\n    }\n    return {\n        isValid: Object.keys(errors).length === 0,\n        errors\n    };\n};\n/**\n * Sanitize team data for safe display\n * @param {Object} team - Team data to sanitize\n * @returns {Object} Sanitized team data\n */ const sanitizeTeam = (team)=>{\n    return {\n        ...team\n    };\n};\n/**\n * Get member role in team\n * @param {Object} team - Team object\n * @param {string} userId - User ID to check\n * @returns {string|null} Member role or null if not a member\n */ const getMemberRole = (team, userId)=>{\n    // Check if user is the owner first (backwards compatibility)\n    if (team.userId === userId) {\n        return 'owner';\n    }\n    // Check in members array\n    const member = team.members.find((m)=>m.userId === userId);\n    return member ? member.role : null;\n};\n/**\n * Check if user has admin privileges in team\n * @param {Object} team - Team object\n * @param {string} userId - User ID to check\n * @returns {boolean} True if user is owner or admin\n */ const isTeamAdmin = (team, userId)=>{\n    const role = getMemberRole(team, userId);\n    return role === 'owner' || role === 'admin';\n};\n/**\n * Check if user is a member of the team\n * @param {Object} team - Team object\n * @param {string} userId - User ID to check\n * @returns {boolean} True if user is a team member\n */ const isTeamMember = (team, userId)=>{\n    return getMemberRole(team, userId) !== null;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uL21vZGVscy90ZWFtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOztDQUVDLEdBRUQ7Ozs7Ozs7Ozs7Q0FVQyxHQUVEOzs7Ozs7Q0FNQyxHQUVEOztDQUVDLEdBQ00sTUFBTUEsWUFBWTtJQUN2QkMsSUFBSTtJQUNKQyxNQUFNO0lBQ05DLGFBQWE7SUFDYkMsUUFBUTtJQUNSQyxTQUFTLEVBQUU7SUFDWEMsV0FBVztJQUNYQyxXQUFXO0FBQ2IsRUFBRTtBQUVGOzs7O0NBSUMsR0FDTSxNQUFNQyxlQUFlLENBQUNDLE1BQU1DLFdBQVcsS0FBSztJQUNqRCxNQUFNQyxTQUFTLENBQUM7SUFFaEIsNENBQTRDO0lBQzVDLElBQUksQ0FBQ0QsWUFBWUQsS0FBS1AsSUFBSSxLQUFLVSxXQUFXO1FBQ3hDLElBQUksQ0FBQ0gsS0FBS1AsSUFBSSxJQUFJTyxLQUFLUCxJQUFJLENBQUNXLElBQUksT0FBTyxJQUFJO1lBQ3pDRixPQUFPVCxJQUFJLEdBQUc7UUFDaEIsT0FBTyxJQUFJTyxLQUFLUCxJQUFJLENBQUNZLE1BQU0sR0FBRyxLQUFLO1lBQ2pDSCxPQUFPVCxJQUFJLEdBQUc7UUFDaEI7SUFDRjtJQUVBLHVDQUF1QztJQUN2QyxJQUFJTyxLQUFLTixXQUFXLElBQUlNLEtBQUtOLFdBQVcsQ0FBQ1csTUFBTSxHQUFHLEtBQUs7UUFDckRILE9BQU9SLFdBQVcsR0FBRztJQUN2QjtJQUVBLGlDQUFpQztJQUNqQyxJQUFJLENBQUNPLFlBQVksQ0FBQ0QsS0FBS0wsTUFBTSxFQUFFO1FBQzdCTyxPQUFPUCxNQUFNLEdBQUc7SUFDbEI7SUFFQSxPQUFPO1FBQ0xXLFNBQVNDLE9BQU9DLElBQUksQ0FBQ04sUUFBUUcsTUFBTSxLQUFLO1FBQ3hDSDtJQUNGO0FBQ0YsRUFBRTtBQUVGOzs7O0NBSUMsR0FDTSxNQUFNTyxlQUFlLENBQUNDO0lBQzNCLE9BQU87UUFDTCxHQUFHQSxJQUFJO0lBRVQ7QUFDRixFQUFFO0FBRUY7Ozs7O0NBS0MsR0FDTSxNQUFNQyxnQkFBZ0IsQ0FBQ0QsTUFBTWY7SUFDbEMsNkRBQTZEO0lBQzdELElBQUllLEtBQUtmLE1BQU0sS0FBS0EsUUFBUTtRQUMxQixPQUFPO0lBQ1Q7SUFFQSx5QkFBeUI7SUFDekIsTUFBTWlCLFNBQVNGLEtBQUtkLE9BQU8sQ0FBQ2lCLElBQUksQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRW5CLE1BQU0sS0FBS0E7SUFDbkQsT0FBT2lCLFNBQVNBLE9BQU9HLElBQUksR0FBRztBQUNoQyxFQUFFO0FBRUY7Ozs7O0NBS0MsR0FDTSxNQUFNQyxjQUFjLENBQUNOLE1BQU1mO0lBQ2hDLE1BQU1vQixPQUFPSixjQUFjRCxNQUFNZjtJQUNqQyxPQUFPb0IsU0FBUyxXQUFXQSxTQUFTO0FBQ3RDLEVBQUU7QUFFRjs7Ozs7Q0FLQyxHQUNNLE1BQU1FLGVBQWUsQ0FBQ1AsTUFBTWY7SUFDakMsT0FBT2dCLGNBQWNELE1BQU1mLFlBQVk7QUFDekMsRUFBRSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxiYXVkaVxcT25lRHJpdmVcXERlc2t0b3BcXFByb21wdFByb1xcUHJvbXB0UHJvXFxtb2RlbHNcXHRlYW0uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUZWFtIGRhdGEgbW9kZWwgYW5kIHZhbGlkYXRpb24gZnVuY3Rpb25zXG4gKi9cblxuLyoqXG4gKiBUZWFtIG1vZGVsIHNjaGVtYVxuICogQHR5cGVkZWYge09iamVjdH0gVGVhbU1vZGVsXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaWQgLSBVbmlxdWUgaWRlbnRpZmllclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgLSBUZWFtIG5hbWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkZXNjcmlwdGlvbiAtIFRlYW0gZGVzY3JpcHRpb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB1c2VySWQgLSBJRCBvZiB0aGUgdGVhbSBjcmVhdG9yL293bmVyXG4gKiBAcHJvcGVydHkge0FycmF5PFRlYW1NZW1iZXI+fSBtZW1iZXJzIC0gQXJyYXkgb2YgdGVhbSBtZW1iZXJzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY3JlYXRlZEF0IC0gQ3JlYXRpb24gdGltZXN0YW1wXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdXBkYXRlZEF0IC0gTGFzdCB1cGRhdGUgdGltZXN0YW1wXG4gKi9cblxuLyoqXG4gKiBUZWFtIG1lbWJlciBzY2hlbWFcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRlYW1NZW1iZXJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB1c2VySWQgLSBVc2VyIElEXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcm9sZSAtIE1lbWJlciByb2xlIChvd25lciwgYWRtaW4sIG1lbWJlcilcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBqb2luZWRBdCAtIFRpbWVzdGFtcCB3aGVuIG1lbWJlciBqb2luZWRcbiAqL1xuXG4vKipcbiAqIFRlYW0gbW9kZWwgZGVmaW5pdGlvblxuICovXG5leHBvcnQgY29uc3QgdGVhbU1vZGVsID0ge1xuICBpZDogJycsXG4gIG5hbWU6ICcnLFxuICBkZXNjcmlwdGlvbjogJycsXG4gIHVzZXJJZDogJycsIC8vIENyZWF0b3Ivb3duZXJcbiAgbWVtYmVyczogW10sIC8vIEFycmF5IG9mIG1lbWJlciBvYmplY3RzXG4gIGNyZWF0ZWRBdDogJycsXG4gIHVwZGF0ZWRBdDogJycsXG59O1xuXG4vKipcbiAqIFZhbGlkYXRlIHRlYW0gZGF0YVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUZWFtIGRhdGEgdG8gdmFsaWRhdGVcbiAqIEByZXR1cm5zIHtPYmplY3R9IFZhbGlkYXRpb24gcmVzdWx0IHdpdGggZXJyb3JzIGlmIGFueVxuICovXG5leHBvcnQgY29uc3QgdmFsaWRhdGVUZWFtID0gKGRhdGEsIGlzVXBkYXRlID0gZmFsc2UpID0+IHtcbiAgY29uc3QgZXJyb3JzID0ge307XG5cbiAgLy8gTmFtZSBpcyByZXF1aXJlZCB1bmxlc3MgdGhpcyBpcyBhbiB1cGRhdGVcbiAgaWYgKCFpc1VwZGF0ZSB8fCBkYXRhLm5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICghZGF0YS5uYW1lIHx8IGRhdGEubmFtZS50cmltKCkgPT09ICcnKSB7XG4gICAgICBlcnJvcnMubmFtZSA9ICdUZWFtIG5hbWUgaXMgcmVxdWlyZWQnO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5uYW1lLmxlbmd0aCA+IDEwMCkge1xuICAgICAgZXJyb3JzLm5hbWUgPSAnVGVhbSBuYW1lIG11c3QgYmUgbGVzcyB0aGFuIDEwMCBjaGFyYWN0ZXJzJztcbiAgICB9XG4gIH1cblxuICAvLyBEZXNjcmlwdGlvbiBsZW5ndGggY2hlY2sgaWYgcHJvdmlkZWRcbiAgaWYgKGRhdGEuZGVzY3JpcHRpb24gJiYgZGF0YS5kZXNjcmlwdGlvbi5sZW5ndGggPiA1MDApIHtcbiAgICBlcnJvcnMuZGVzY3JpcHRpb24gPSAnVGVhbSBkZXNjcmlwdGlvbiBtdXN0IGJlIGxlc3MgdGhhbiA1MDAgY2hhcmFjdGVycyc7XG4gIH1cblxuICAvLyBDcmVhdG9yIHJlcXVpcmVkIGZvciBuZXcgdGVhbXNcbiAgaWYgKCFpc1VwZGF0ZSAmJiAhZGF0YS51c2VySWQpIHtcbiAgICBlcnJvcnMudXNlcklkID0gJ0NyZWF0b3IgSUQgaXMgcmVxdWlyZWQnO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBpc1ZhbGlkOiBPYmplY3Qua2V5cyhlcnJvcnMpLmxlbmd0aCA9PT0gMCxcbiAgICBlcnJvcnMsXG4gIH07XG59O1xuXG4vKipcbiAqIFNhbml0aXplIHRlYW0gZGF0YSBmb3Igc2FmZSBkaXNwbGF5XG4gKiBAcGFyYW0ge09iamVjdH0gdGVhbSAtIFRlYW0gZGF0YSB0byBzYW5pdGl6ZVxuICogQHJldHVybnMge09iamVjdH0gU2FuaXRpemVkIHRlYW0gZGF0YVxuICovXG5leHBvcnQgY29uc3Qgc2FuaXRpemVUZWFtID0gKHRlYW0pID0+IHtcbiAgcmV0dXJuIHtcbiAgICAuLi50ZWFtLFxuICAgIC8vIFJlbW92ZSBhbnkgc2Vuc2l0aXZlIGluZm9ybWF0aW9uIGlmIG5lZWRlZFxuICB9O1xufTtcblxuLyoqXG4gKiBHZXQgbWVtYmVyIHJvbGUgaW4gdGVhbVxuICogQHBhcmFtIHtPYmplY3R9IHRlYW0gLSBUZWFtIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCAtIFVzZXIgSUQgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gTWVtYmVyIHJvbGUgb3IgbnVsbCBpZiBub3QgYSBtZW1iZXJcbiAqL1xuZXhwb3J0IGNvbnN0IGdldE1lbWJlclJvbGUgPSAodGVhbSwgdXNlcklkKSA9PiB7XG4gIC8vIENoZWNrIGlmIHVzZXIgaXMgdGhlIG93bmVyIGZpcnN0IChiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSlcbiAgaWYgKHRlYW0udXNlcklkID09PSB1c2VySWQpIHtcbiAgICByZXR1cm4gJ293bmVyJztcbiAgfVxuICBcbiAgLy8gQ2hlY2sgaW4gbWVtYmVycyBhcnJheVxuICBjb25zdCBtZW1iZXIgPSB0ZWFtLm1lbWJlcnMuZmluZChtID0+IG0udXNlcklkID09PSB1c2VySWQpO1xuICByZXR1cm4gbWVtYmVyID8gbWVtYmVyLnJvbGUgOiBudWxsO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB1c2VyIGhhcyBhZG1pbiBwcml2aWxlZ2VzIGluIHRlYW1cbiAqIEBwYXJhbSB7T2JqZWN0fSB0ZWFtIC0gVGVhbSBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgLSBVc2VyIElEIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB1c2VyIGlzIG93bmVyIG9yIGFkbWluXG4gKi9cbmV4cG9ydCBjb25zdCBpc1RlYW1BZG1pbiA9ICh0ZWFtLCB1c2VySWQpID0+IHtcbiAgY29uc3Qgcm9sZSA9IGdldE1lbWJlclJvbGUodGVhbSwgdXNlcklkKTtcbiAgcmV0dXJuIHJvbGUgPT09ICdvd25lcicgfHwgcm9sZSA9PT0gJ2FkbWluJztcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdXNlciBpcyBhIG1lbWJlciBvZiB0aGUgdGVhbVxuICogQHBhcmFtIHtPYmplY3R9IHRlYW0gLSBUZWFtIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCAtIFVzZXIgSUQgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHVzZXIgaXMgYSB0ZWFtIG1lbWJlclxuICovXG5leHBvcnQgY29uc3QgaXNUZWFtTWVtYmVyID0gKHRlYW0sIHVzZXJJZCkgPT4ge1xuICByZXR1cm4gZ2V0TWVtYmVyUm9sZSh0ZWFtLCB1c2VySWQpICE9PSBudWxsO1xufTsiXSwibmFtZXMiOlsidGVhbU1vZGVsIiwiaWQiLCJuYW1lIiwiZGVzY3JpcHRpb24iLCJ1c2VySWQiLCJtZW1iZXJzIiwiY3JlYXRlZEF0IiwidXBkYXRlZEF0IiwidmFsaWRhdGVUZWFtIiwiZGF0YSIsImlzVXBkYXRlIiwiZXJyb3JzIiwidW5kZWZpbmVkIiwidHJpbSIsImxlbmd0aCIsImlzVmFsaWQiLCJPYmplY3QiLCJrZXlzIiwic2FuaXRpemVUZWFtIiwidGVhbSIsImdldE1lbWJlclJvbGUiLCJtZW1iZXIiLCJmaW5kIiwibSIsInJvbGUiLCJpc1RlYW1BZG1pbiIsImlzVGVhbU1lbWJlciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api-node)/./models/team.js\n");

/***/ }),

/***/ "(api-node)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fprompts&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cprompts%5Cindex.js&middlewareConfigBase64=e30%3D!":
/*!****************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fprompts&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cprompts%5Cindex.js&middlewareConfigBase64=e30%3D! ***!
  \****************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   routeModule: () => (/* binding */ routeModule)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/route-modules/pages-api/module.compiled */ \"(api-node)/./node_modules/next/dist/server/route-modules/pages-api/module.compiled.js\");\n/* harmony import */ var next_dist_server_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/route-kind */ \"(api-node)/./node_modules/next/dist/server/route-kind.js\");\n/* harmony import */ var next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/build/templates/helpers */ \"(api-node)/./node_modules/next/dist/build/templates/helpers.js\");\n/* harmony import */ var _pages_api_prompts_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pages\\api\\prompts\\index.js */ \"(api-node)/./pages/api/prompts/index.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_pages_api_prompts_index_js__WEBPACK_IMPORTED_MODULE_3__]);\n_pages_api_prompts_index_js__WEBPACK_IMPORTED_MODULE_3__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n// Import the userland code.\n\n// Re-export the handler (should be the default export).\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_prompts_index_js__WEBPACK_IMPORTED_MODULE_3__, 'default'));\n// Re-export config.\nconst config = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_prompts_index_js__WEBPACK_IMPORTED_MODULE_3__, 'config');\n// Create and export the route module that will be consumed.\nconst routeModule = new next_dist_server_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__.PagesAPIRouteModule({\n    definition: {\n        kind: next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.PAGES_API,\n        page: \"/api/prompts\",\n        pathname: \"/api/prompts\",\n        // The following aren't used in production.\n        bundlePath: '',\n        filename: ''\n    },\n    userland: _pages_api_prompts_index_js__WEBPACK_IMPORTED_MODULE_3__\n});\n\n//# sourceMappingURL=pages-api.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtcm91dGUtbG9hZGVyL2luZGV4LmpzP2tpbmQ9UEFHRVNfQVBJJnBhZ2U9JTJGYXBpJTJGcHJvbXB0cyZwcmVmZXJyZWRSZWdpb249JmFic29sdXRlUGFnZVBhdGg9LiUyRnBhZ2VzJTVDYXBpJTVDcHJvbXB0cyU1Q2luZGV4LmpzJm1pZGRsZXdhcmVDb25maWdCYXNlNjQ9ZTMwJTNEISIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUErRjtBQUN2QztBQUNFO0FBQzFEO0FBQzREO0FBQzVEO0FBQ0EsaUVBQWUsd0VBQUssQ0FBQyx3REFBUSxZQUFZLEVBQUM7QUFDMUM7QUFDTyxlQUFlLHdFQUFLLENBQUMsd0RBQVE7QUFDcEM7QUFDTyx3QkFBd0IseUdBQW1CO0FBQ2xEO0FBQ0EsY0FBYyxrRUFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVk7QUFDWixDQUFDOztBQUVELHFDIiwic291cmNlcyI6WyIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGFnZXNBUElSb3V0ZU1vZHVsZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL3JvdXRlLW1vZHVsZXMvcGFnZXMtYXBpL21vZHVsZS5jb21waWxlZFwiO1xuaW1wb3J0IHsgUm91dGVLaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvcm91dGUta2luZFwiO1xuaW1wb3J0IHsgaG9pc3QgfSBmcm9tIFwibmV4dC9kaXN0L2J1aWxkL3RlbXBsYXRlcy9oZWxwZXJzXCI7XG4vLyBJbXBvcnQgdGhlIHVzZXJsYW5kIGNvZGUuXG5pbXBvcnQgKiBhcyB1c2VybGFuZCBmcm9tIFwiLi9wYWdlc1xcXFxhcGlcXFxccHJvbXB0c1xcXFxpbmRleC5qc1wiO1xuLy8gUmUtZXhwb3J0IHRoZSBoYW5kbGVyIChzaG91bGQgYmUgdGhlIGRlZmF1bHQgZXhwb3J0KS5cbmV4cG9ydCBkZWZhdWx0IGhvaXN0KHVzZXJsYW5kLCAnZGVmYXVsdCcpO1xuLy8gUmUtZXhwb3J0IGNvbmZpZy5cbmV4cG9ydCBjb25zdCBjb25maWcgPSBob2lzdCh1c2VybGFuZCwgJ2NvbmZpZycpO1xuLy8gQ3JlYXRlIGFuZCBleHBvcnQgdGhlIHJvdXRlIG1vZHVsZSB0aGF0IHdpbGwgYmUgY29uc3VtZWQuXG5leHBvcnQgY29uc3Qgcm91dGVNb2R1bGUgPSBuZXcgUGFnZXNBUElSb3V0ZU1vZHVsZSh7XG4gICAgZGVmaW5pdGlvbjoge1xuICAgICAgICBraW5kOiBSb3V0ZUtpbmQuUEFHRVNfQVBJLFxuICAgICAgICBwYWdlOiBcIi9hcGkvcHJvbXB0c1wiLFxuICAgICAgICBwYXRobmFtZTogXCIvYXBpL3Byb21wdHNcIixcbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBhcmVuJ3QgdXNlZCBpbiBwcm9kdWN0aW9uLlxuICAgICAgICBidW5kbGVQYXRoOiAnJyxcbiAgICAgICAgZmlsZW5hbWU6ICcnXG4gICAgfSxcbiAgICB1c2VybGFuZFxufSk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhZ2VzLWFwaS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api-node)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fprompts&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cprompts%5Cindex.js&middlewareConfigBase64=e30%3D!\n");

/***/ }),

/***/ "(api-node)/./pages/api/prompts/index.js":
/*!************************************!*\
  !*** ./pages/api/prompts/index.js ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _models_prompt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../models/prompt */ \"(api-node)/./models/prompt.js\");\n/* harmony import */ var _lib_auth__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../lib/auth */ \"(api-node)/./lib/auth.js\");\n/* harmony import */ var _lib_repositories_promptRepository__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../lib/repositories/promptRepository */ \"(api-node)/./lib/repositories/promptRepository.js\");\n/* harmony import */ var _models_team__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../models/team */ \"(api-node)/./models/team.js\");\n/* harmony import */ var _lib_db__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../lib/db */ \"(api-node)/./lib/db.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_lib_db__WEBPACK_IMPORTED_MODULE_4__]);\n_lib_db__WEBPACK_IMPORTED_MODULE_4__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n\n\nasync function handler(req, res) {\n    // Set cache control headers to prevent caching\n    res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate, proxy-revalidate');\n    res.setHeader('Pragma', 'no-cache');\n    res.setHeader('Expires', '0');\n    switch(req.method){\n        case 'GET':\n            return getPrompts(req, res);\n        case 'POST':\n            return addPrompt(req, res);\n        default:\n            return res.status(405).json({\n                message: 'Method not allowed'\n            });\n    }\n}\n// Apply authentication to POST method\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_lib_auth__WEBPACK_IMPORTED_MODULE_1__.withAuthForMethods)(handler, [\n    'POST'\n]));\nasync function getPrompts(req, res) {\n    try {\n        // Get query parameters for filtering\n        const { userId, visibility, aiPlatform, tags, teamId } = req.query;\n        // Create filter object\n        const filter = {};\n        if (userId) filter.userId = userId;\n        if (visibility) filter.visibility = visibility;\n        if (aiPlatform) filter.aiPlatform = aiPlatform;\n        if (teamId) filter.teamId = teamId;\n        // Parse tags if provided\n        if (tags) {\n            filter.tags = Array.isArray(tags) ? tags : [\n                tags\n            ];\n        }\n        // Get the current user ID if authenticated\n        const currentUserId = req.session?.sub || null;\n        // Get prompts from repository\n        let prompts = await _lib_repositories_promptRepository__WEBPACK_IMPORTED_MODULE_2__.getAllPrompts(filter);\n        // If the user is authenticated, filter prompts based on visibility\n        if (currentUserId) {\n            // If a specific teamId is requested, verify membership\n            if (teamId) {\n                const userTeams = await (0,_lib_db__WEBPACK_IMPORTED_MODULE_4__.getUserTeams)(currentUserId);\n                const team = userTeams.find((t)=>t.id === teamId);\n                if (!team || !(0,_models_team__WEBPACK_IMPORTED_MODULE_3__.isTeamMember)(team, currentUserId)) {\n                    return res.status(403).json({\n                        message: 'Not authorized to view prompts from this team'\n                    });\n                }\n            }\n            // If no specific filter is provided, apply visibility-based filtering\n            if (!filter.visibility && !filter.teamId) {\n                // Get all teams the user is a member of\n                const userTeams = await (0,_lib_db__WEBPACK_IMPORTED_MODULE_4__.getUserTeams)(currentUserId);\n                const userTeamIds = userTeams.map((team)=>team.id);\n                // Filter prompts based on visibility and team membership\n                prompts = prompts.filter((prompt)=>{\n                    // Public prompts are visible to everyone\n                    if (prompt.visibility === 'public') return true;\n                    // Private prompts are only visible to creator\n                    if (prompt.visibility === 'private') {\n                        return String(prompt.userId) === String(currentUserId);\n                    }\n                    // Team prompts are visible to team members\n                    if (prompt.visibility === 'team' && prompt.teamId) {\n                        return userTeamIds.includes(prompt.teamId);\n                    }\n                    return false;\n                });\n            }\n        } else {\n            // For non-authenticated users, only return public prompts\n            prompts = prompts.filter((prompt)=>prompt.visibility === 'public');\n        }\n        return res.status(200).json(prompts);\n    } catch (error) {\n        console.error('Error getting prompts:', error);\n        return res.status(500).json({\n            message: 'Internal server error'\n        });\n    }\n}\nasync function addPrompt(req, res) {\n    try {\n        const promptData = req.body;\n        // Add user info from session\n        const userId = req.session?.sub;\n        const userName = req.session?.user?.name || 'Unknown User';\n        console.log('Creating prompt with user ID:', userId);\n        if (!userId) {\n            return res.status(401).json({\n                message: 'Authentication required'\n            });\n        }\n        // For team prompts, verify team membership\n        if (promptData.visibility === 'team' && promptData.teamId) {\n            const userTeams = await (0,_lib_db__WEBPACK_IMPORTED_MODULE_4__.getUserTeams)(userId);\n            const isTeamMember = userTeams.some((team)=>team.id === promptData.teamId);\n            if (!isTeamMember) {\n                return res.status(403).json({\n                    message: 'You must be a team member to create prompts for this team'\n                });\n            }\n        }\n        // Validate prompt data\n        const { isValid, errors } = (0,_models_prompt__WEBPACK_IMPORTED_MODULE_0__.validatePrompt)(promptData);\n        if (!isValid) {\n            return res.status(400).json({\n                message: 'Validation failed',\n                errors\n            });\n        }\n        // Create new prompt with userId explicitly set\n        const newPrompt = await _lib_repositories_promptRepository__WEBPACK_IMPORTED_MODULE_2__.createPrompt({\n            ...promptData,\n            userId,\n            createdBy: userName\n        });\n        console.log('Successfully created prompt:', newPrompt);\n        return res.status(201).json(newPrompt);\n    } catch (error) {\n        console.error('Error creating prompt:', error);\n        return res.status(500).json({\n            message: 'Internal server error'\n        });\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uL3BhZ2VzL2FwaS9wcm9tcHRzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUF3RDtBQUNEO0FBQ3dCO0FBQzNCO0FBQ0w7QUFFL0MsZUFBZUssUUFBUUMsR0FBRyxFQUFFQyxHQUFHO0lBQzdCLCtDQUErQztJQUMvQ0EsSUFBSUMsU0FBUyxDQUFDLGlCQUFpQjtJQUMvQkQsSUFBSUMsU0FBUyxDQUFDLFVBQVU7SUFDeEJELElBQUlDLFNBQVMsQ0FBQyxXQUFXO0lBRXpCLE9BQVFGLElBQUlHLE1BQU07UUFDaEIsS0FBSztZQUNILE9BQU9DLFdBQVdKLEtBQUtDO1FBQ3pCLEtBQUs7WUFDSCxPQUFPSSxVQUFVTCxLQUFLQztRQUN4QjtZQUNFLE9BQU9BLElBQUlLLE1BQU0sQ0FBQyxLQUFLQyxJQUFJLENBQUM7Z0JBQUVDLFNBQVM7WUFBcUI7SUFDaEU7QUFDRjtBQUVBLHNDQUFzQztBQUN0QyxpRUFBZWIsNkRBQWtCQSxDQUFDSSxTQUFTO0lBQUM7Q0FBTyxDQUFDLEVBQUM7QUFFckQsZUFBZUssV0FBV0osR0FBRyxFQUFFQyxHQUFHO0lBQ2hDLElBQUk7UUFDRixxQ0FBcUM7UUFDckMsTUFBTSxFQUFFUSxNQUFNLEVBQUVDLFVBQVUsRUFBRUMsVUFBVSxFQUFFQyxJQUFJLEVBQUVDLE1BQU0sRUFBRSxHQUFHYixJQUFJYyxLQUFLO1FBRWxFLHVCQUF1QjtRQUN2QixNQUFNQyxTQUFTLENBQUM7UUFFaEIsSUFBSU4sUUFBUU0sT0FBT04sTUFBTSxHQUFHQTtRQUM1QixJQUFJQyxZQUFZSyxPQUFPTCxVQUFVLEdBQUdBO1FBQ3BDLElBQUlDLFlBQVlJLE9BQU9KLFVBQVUsR0FBR0E7UUFDcEMsSUFBSUUsUUFBUUUsT0FBT0YsTUFBTSxHQUFHQTtRQUU1Qix5QkFBeUI7UUFDekIsSUFBSUQsTUFBTTtZQUNSRyxPQUFPSCxJQUFJLEdBQUdJLE1BQU1DLE9BQU8sQ0FBQ0wsUUFBUUEsT0FBTztnQkFBQ0E7YUFBSztRQUNuRDtRQUVBLDJDQUEyQztRQUMzQyxNQUFNTSxnQkFBZ0JsQixJQUFJbUIsT0FBTyxFQUFFQyxPQUFPO1FBRTFDLDhCQUE4QjtRQUM5QixJQUFJQyxVQUFVLE1BQU16Qiw2RUFBOEIsQ0FBQ21CO1FBRW5ELG1FQUFtRTtRQUNuRSxJQUFJRyxlQUFlO1lBQ2pCLHVEQUF1RDtZQUN2RCxJQUFJTCxRQUFRO2dCQUNWLE1BQU1VLFlBQVksTUFBTXpCLHFEQUFZQSxDQUFDb0I7Z0JBQ3JDLE1BQU1NLE9BQU9ELFVBQVVFLElBQUksQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUMsRUFBRSxLQUFLZDtnQkFFMUMsSUFBSSxDQUFDVyxRQUFRLENBQUMzQiwwREFBWUEsQ0FBQzJCLE1BQU1OLGdCQUFnQjtvQkFDL0MsT0FBT2pCLElBQUlLLE1BQU0sQ0FBQyxLQUFLQyxJQUFJLENBQUM7d0JBQUVDLFNBQVM7b0JBQWdEO2dCQUN6RjtZQUNGO1lBRUEsc0VBQXNFO1lBQ3RFLElBQUksQ0FBQ08sT0FBT0wsVUFBVSxJQUFJLENBQUNLLE9BQU9GLE1BQU0sRUFBRTtnQkFDeEMsd0NBQXdDO2dCQUN4QyxNQUFNVSxZQUFZLE1BQU16QixxREFBWUEsQ0FBQ29CO2dCQUNyQyxNQUFNVSxjQUFjTCxVQUFVTSxHQUFHLENBQUNMLENBQUFBLE9BQVFBLEtBQUtHLEVBQUU7Z0JBRWpELHlEQUF5RDtnQkFDekROLFVBQVVBLFFBQVFOLE1BQU0sQ0FBQ2UsQ0FBQUE7b0JBQ3ZCLHlDQUF5QztvQkFDekMsSUFBSUEsT0FBT3BCLFVBQVUsS0FBSyxVQUFVLE9BQU87b0JBRTNDLDhDQUE4QztvQkFDOUMsSUFBSW9CLE9BQU9wQixVQUFVLEtBQUssV0FBVzt3QkFDbkMsT0FBT3FCLE9BQU9ELE9BQU9yQixNQUFNLE1BQU1zQixPQUFPYjtvQkFDMUM7b0JBRUEsMkNBQTJDO29CQUMzQyxJQUFJWSxPQUFPcEIsVUFBVSxLQUFLLFVBQVVvQixPQUFPakIsTUFBTSxFQUFFO3dCQUNqRCxPQUFPZSxZQUFZSSxRQUFRLENBQUNGLE9BQU9qQixNQUFNO29CQUMzQztvQkFFQSxPQUFPO2dCQUNUO1lBQ0Y7UUFDRixPQUFPO1lBQ0wsMERBQTBEO1lBQzFEUSxVQUFVQSxRQUFRTixNQUFNLENBQUNlLENBQUFBLFNBQVVBLE9BQU9wQixVQUFVLEtBQUs7UUFDM0Q7UUFFQSxPQUFPVCxJQUFJSyxNQUFNLENBQUMsS0FBS0MsSUFBSSxDQUFDYztJQUM5QixFQUFFLE9BQU9ZLE9BQU87UUFDZEMsUUFBUUQsS0FBSyxDQUFDLDBCQUEwQkE7UUFDeEMsT0FBT2hDLElBQUlLLE1BQU0sQ0FBQyxLQUFLQyxJQUFJLENBQUM7WUFBRUMsU0FBUztRQUF3QjtJQUNqRTtBQUNGO0FBRUEsZUFBZUgsVUFBVUwsR0FBRyxFQUFFQyxHQUFHO0lBQy9CLElBQUk7UUFDRixNQUFNa0MsYUFBYW5DLElBQUlvQyxJQUFJO1FBRTNCLDZCQUE2QjtRQUM3QixNQUFNM0IsU0FBU1QsSUFBSW1CLE9BQU8sRUFBRUM7UUFDNUIsTUFBTWlCLFdBQVdyQyxJQUFJbUIsT0FBTyxFQUFFbUIsTUFBTUMsUUFBUTtRQUU1Q0wsUUFBUU0sR0FBRyxDQUFDLGlDQUFpQy9CO1FBRTdDLElBQUksQ0FBQ0EsUUFBUTtZQUNYLE9BQU9SLElBQUlLLE1BQU0sQ0FBQyxLQUFLQyxJQUFJLENBQUM7Z0JBQUVDLFNBQVM7WUFBMEI7UUFDbkU7UUFFQSwyQ0FBMkM7UUFDM0MsSUFBSTJCLFdBQVd6QixVQUFVLEtBQUssVUFBVXlCLFdBQVd0QixNQUFNLEVBQUU7WUFDekQsTUFBTVUsWUFBWSxNQUFNekIscURBQVlBLENBQUNXO1lBQ3JDLE1BQU1aLGVBQWUwQixVQUFVa0IsSUFBSSxDQUFDakIsQ0FBQUEsT0FBUUEsS0FBS0csRUFBRSxLQUFLUSxXQUFXdEIsTUFBTTtZQUV6RSxJQUFJLENBQUNoQixjQUFjO2dCQUNqQixPQUFPSSxJQUFJSyxNQUFNLENBQUMsS0FBS0MsSUFBSSxDQUFDO29CQUFFQyxTQUFTO2dCQUE0RDtZQUNyRztRQUNGO1FBRUEsdUJBQXVCO1FBQ3ZCLE1BQU0sRUFBRWtDLE9BQU8sRUFBRUMsTUFBTSxFQUFFLEdBQUdqRCw4REFBY0EsQ0FBQ3lDO1FBRTNDLElBQUksQ0FBQ08sU0FBUztZQUNaLE9BQU96QyxJQUFJSyxNQUFNLENBQUMsS0FBS0MsSUFBSSxDQUFDO2dCQUFFQyxTQUFTO2dCQUFxQm1DO1lBQU87UUFDckU7UUFFQSwrQ0FBK0M7UUFDL0MsTUFBTUMsWUFBWSxNQUFNaEQsNEVBQTZCLENBQUM7WUFDcEQsR0FBR3VDLFVBQVU7WUFDYjFCO1lBQ0FxQyxXQUFXVDtRQUNiO1FBRUFILFFBQVFNLEdBQUcsQ0FBQyxnQ0FBZ0NJO1FBRTVDLE9BQU8zQyxJQUFJSyxNQUFNLENBQUMsS0FBS0MsSUFBSSxDQUFDcUM7SUFDOUIsRUFBRSxPQUFPWCxPQUFPO1FBQ2RDLFFBQVFELEtBQUssQ0FBQywwQkFBMEJBO1FBQ3hDLE9BQU9oQyxJQUFJSyxNQUFNLENBQUMsS0FBS0MsSUFBSSxDQUFDO1lBQUVDLFNBQVM7UUFBd0I7SUFDakU7QUFDRiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxiYXVkaVxcT25lRHJpdmVcXERlc2t0b3BcXFByb21wdFByb1xcUHJvbXB0UHJvXFxwYWdlc1xcYXBpXFxwcm9tcHRzXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB2YWxpZGF0ZVByb21wdCB9IGZyb20gJy4uLy4uLy4uL21vZGVscy9wcm9tcHQnO1xuaW1wb3J0IHsgd2l0aEF1dGhGb3JNZXRob2RzIH0gZnJvbSAnLi4vLi4vLi4vbGliL2F1dGgnO1xuaW1wb3J0ICogYXMgcHJvbXB0UmVwb3NpdG9yeSBmcm9tICcuLi8uLi8uLi9saWIvcmVwb3NpdG9yaWVzL3Byb21wdFJlcG9zaXRvcnknO1xuaW1wb3J0IHsgaXNUZWFtTWVtYmVyIH0gZnJvbSAnLi4vLi4vLi4vbW9kZWxzL3RlYW0nO1xuaW1wb3J0IHsgZ2V0VXNlclRlYW1zIH0gZnJvbSAnLi4vLi4vLi4vbGliL2RiJztcblxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlcihyZXEsIHJlcykge1xuICAvLyBTZXQgY2FjaGUgY29udHJvbCBoZWFkZXJzIHRvIHByZXZlbnQgY2FjaGluZ1xuICByZXMuc2V0SGVhZGVyKCdDYWNoZS1Db250cm9sJywgJ25vLXN0b3JlLCBuby1jYWNoZSwgbXVzdC1yZXZhbGlkYXRlLCBwcm94eS1yZXZhbGlkYXRlJyk7XG4gIHJlcy5zZXRIZWFkZXIoJ1ByYWdtYScsICduby1jYWNoZScpO1xuICByZXMuc2V0SGVhZGVyKCdFeHBpcmVzJywgJzAnKTtcblxuICBzd2l0Y2ggKHJlcS5tZXRob2QpIHtcbiAgICBjYXNlICdHRVQnOlxuICAgICAgcmV0dXJuIGdldFByb21wdHMocmVxLCByZXMpO1xuICAgIGNhc2UgJ1BPU1QnOlxuICAgICAgcmV0dXJuIGFkZFByb21wdChyZXEsIHJlcyk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKDQwNSkuanNvbih7IG1lc3NhZ2U6ICdNZXRob2Qgbm90IGFsbG93ZWQnIH0pO1xuICB9XG59XG5cbi8vIEFwcGx5IGF1dGhlbnRpY2F0aW9uIHRvIFBPU1QgbWV0aG9kXG5leHBvcnQgZGVmYXVsdCB3aXRoQXV0aEZvck1ldGhvZHMoaGFuZGxlciwgWydQT1NUJ10pO1xuXG5hc3luYyBmdW5jdGlvbiBnZXRQcm9tcHRzKHJlcSwgcmVzKSB7XG4gIHRyeSB7XG4gICAgLy8gR2V0IHF1ZXJ5IHBhcmFtZXRlcnMgZm9yIGZpbHRlcmluZ1xuICAgIGNvbnN0IHsgdXNlcklkLCB2aXNpYmlsaXR5LCBhaVBsYXRmb3JtLCB0YWdzLCB0ZWFtSWQgfSA9IHJlcS5xdWVyeTtcbiAgICBcbiAgICAvLyBDcmVhdGUgZmlsdGVyIG9iamVjdFxuICAgIGNvbnN0IGZpbHRlciA9IHt9O1xuICAgIFxuICAgIGlmICh1c2VySWQpIGZpbHRlci51c2VySWQgPSB1c2VySWQ7XG4gICAgaWYgKHZpc2liaWxpdHkpIGZpbHRlci52aXNpYmlsaXR5ID0gdmlzaWJpbGl0eTtcbiAgICBpZiAoYWlQbGF0Zm9ybSkgZmlsdGVyLmFpUGxhdGZvcm0gPSBhaVBsYXRmb3JtO1xuICAgIGlmICh0ZWFtSWQpIGZpbHRlci50ZWFtSWQgPSB0ZWFtSWQ7XG4gICAgXG4gICAgLy8gUGFyc2UgdGFncyBpZiBwcm92aWRlZFxuICAgIGlmICh0YWdzKSB7XG4gICAgICBmaWx0ZXIudGFncyA9IEFycmF5LmlzQXJyYXkodGFncykgPyB0YWdzIDogW3RhZ3NdO1xuICAgIH1cbiAgICBcbiAgICAvLyBHZXQgdGhlIGN1cnJlbnQgdXNlciBJRCBpZiBhdXRoZW50aWNhdGVkXG4gICAgY29uc3QgY3VycmVudFVzZXJJZCA9IHJlcS5zZXNzaW9uPy5zdWIgfHwgbnVsbDtcbiAgICBcbiAgICAvLyBHZXQgcHJvbXB0cyBmcm9tIHJlcG9zaXRvcnlcbiAgICBsZXQgcHJvbXB0cyA9IGF3YWl0IHByb21wdFJlcG9zaXRvcnkuZ2V0QWxsUHJvbXB0cyhmaWx0ZXIpO1xuICAgIFxuICAgIC8vIElmIHRoZSB1c2VyIGlzIGF1dGhlbnRpY2F0ZWQsIGZpbHRlciBwcm9tcHRzIGJhc2VkIG9uIHZpc2liaWxpdHlcbiAgICBpZiAoY3VycmVudFVzZXJJZCkge1xuICAgICAgLy8gSWYgYSBzcGVjaWZpYyB0ZWFtSWQgaXMgcmVxdWVzdGVkLCB2ZXJpZnkgbWVtYmVyc2hpcFxuICAgICAgaWYgKHRlYW1JZCkge1xuICAgICAgICBjb25zdCB1c2VyVGVhbXMgPSBhd2FpdCBnZXRVc2VyVGVhbXMoY3VycmVudFVzZXJJZCk7XG4gICAgICAgIGNvbnN0IHRlYW0gPSB1c2VyVGVhbXMuZmluZCh0ID0+IHQuaWQgPT09IHRlYW1JZCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIXRlYW0gfHwgIWlzVGVhbU1lbWJlcih0ZWFtLCBjdXJyZW50VXNlcklkKSkge1xuICAgICAgICAgIHJldHVybiByZXMuc3RhdHVzKDQwMykuanNvbih7IG1lc3NhZ2U6ICdOb3QgYXV0aG9yaXplZCB0byB2aWV3IHByb21wdHMgZnJvbSB0aGlzIHRlYW0nIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIElmIG5vIHNwZWNpZmljIGZpbHRlciBpcyBwcm92aWRlZCwgYXBwbHkgdmlzaWJpbGl0eS1iYXNlZCBmaWx0ZXJpbmdcbiAgICAgIGlmICghZmlsdGVyLnZpc2liaWxpdHkgJiYgIWZpbHRlci50ZWFtSWQpIHtcbiAgICAgICAgLy8gR2V0IGFsbCB0ZWFtcyB0aGUgdXNlciBpcyBhIG1lbWJlciBvZlxuICAgICAgICBjb25zdCB1c2VyVGVhbXMgPSBhd2FpdCBnZXRVc2VyVGVhbXMoY3VycmVudFVzZXJJZCk7XG4gICAgICAgIGNvbnN0IHVzZXJUZWFtSWRzID0gdXNlclRlYW1zLm1hcCh0ZWFtID0+IHRlYW0uaWQpO1xuICAgICAgICBcbiAgICAgICAgLy8gRmlsdGVyIHByb21wdHMgYmFzZWQgb24gdmlzaWJpbGl0eSBhbmQgdGVhbSBtZW1iZXJzaGlwXG4gICAgICAgIHByb21wdHMgPSBwcm9tcHRzLmZpbHRlcihwcm9tcHQgPT4ge1xuICAgICAgICAgIC8vIFB1YmxpYyBwcm9tcHRzIGFyZSB2aXNpYmxlIHRvIGV2ZXJ5b25lXG4gICAgICAgICAgaWYgKHByb21wdC52aXNpYmlsaXR5ID09PSAncHVibGljJykgcmV0dXJuIHRydWU7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUHJpdmF0ZSBwcm9tcHRzIGFyZSBvbmx5IHZpc2libGUgdG8gY3JlYXRvclxuICAgICAgICAgIGlmIChwcm9tcHQudmlzaWJpbGl0eSA9PT0gJ3ByaXZhdGUnKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKHByb21wdC51c2VySWQpID09PSBTdHJpbmcoY3VycmVudFVzZXJJZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFRlYW0gcHJvbXB0cyBhcmUgdmlzaWJsZSB0byB0ZWFtIG1lbWJlcnNcbiAgICAgICAgICBpZiAocHJvbXB0LnZpc2liaWxpdHkgPT09ICd0ZWFtJyAmJiBwcm9tcHQudGVhbUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gdXNlclRlYW1JZHMuaW5jbHVkZXMocHJvbXB0LnRlYW1JZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciBub24tYXV0aGVudGljYXRlZCB1c2Vycywgb25seSByZXR1cm4gcHVibGljIHByb21wdHNcbiAgICAgIHByb21wdHMgPSBwcm9tcHRzLmZpbHRlcihwcm9tcHQgPT4gcHJvbXB0LnZpc2liaWxpdHkgPT09ICdwdWJsaWMnKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHJlcy5zdGF0dXMoMjAwKS5qc29uKHByb21wdHMpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgcHJvbXB0czonLCBlcnJvcik7XG4gICAgcmV0dXJuIHJlcy5zdGF0dXMoNTAwKS5qc29uKHsgbWVzc2FnZTogJ0ludGVybmFsIHNlcnZlciBlcnJvcicgfSk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gYWRkUHJvbXB0KHJlcSwgcmVzKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcHJvbXB0RGF0YSA9IHJlcS5ib2R5O1xuICAgIFxuICAgIC8vIEFkZCB1c2VyIGluZm8gZnJvbSBzZXNzaW9uXG4gICAgY29uc3QgdXNlcklkID0gcmVxLnNlc3Npb24/LnN1YjtcbiAgICBjb25zdCB1c2VyTmFtZSA9IHJlcS5zZXNzaW9uPy51c2VyPy5uYW1lIHx8ICdVbmtub3duIFVzZXInO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCdDcmVhdGluZyBwcm9tcHQgd2l0aCB1c2VyIElEOicsIHVzZXJJZCk7XG4gICAgXG4gICAgaWYgKCF1c2VySWQpIHtcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKDQwMSkuanNvbih7IG1lc3NhZ2U6ICdBdXRoZW50aWNhdGlvbiByZXF1aXJlZCcgfSk7XG4gICAgfVxuICAgIFxuICAgIC8vIEZvciB0ZWFtIHByb21wdHMsIHZlcmlmeSB0ZWFtIG1lbWJlcnNoaXBcbiAgICBpZiAocHJvbXB0RGF0YS52aXNpYmlsaXR5ID09PSAndGVhbScgJiYgcHJvbXB0RGF0YS50ZWFtSWQpIHtcbiAgICAgIGNvbnN0IHVzZXJUZWFtcyA9IGF3YWl0IGdldFVzZXJUZWFtcyh1c2VySWQpO1xuICAgICAgY29uc3QgaXNUZWFtTWVtYmVyID0gdXNlclRlYW1zLnNvbWUodGVhbSA9PiB0ZWFtLmlkID09PSBwcm9tcHREYXRhLnRlYW1JZCk7XG4gICAgICBcbiAgICAgIGlmICghaXNUZWFtTWVtYmVyKSB7XG4gICAgICAgIHJldHVybiByZXMuc3RhdHVzKDQwMykuanNvbih7IG1lc3NhZ2U6ICdZb3UgbXVzdCBiZSBhIHRlYW0gbWVtYmVyIHRvIGNyZWF0ZSBwcm9tcHRzIGZvciB0aGlzIHRlYW0nIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBWYWxpZGF0ZSBwcm9tcHQgZGF0YVxuICAgIGNvbnN0IHsgaXNWYWxpZCwgZXJyb3JzIH0gPSB2YWxpZGF0ZVByb21wdChwcm9tcHREYXRhKTtcbiAgICBcbiAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKDQwMCkuanNvbih7IG1lc3NhZ2U6ICdWYWxpZGF0aW9uIGZhaWxlZCcsIGVycm9ycyB9KTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ3JlYXRlIG5ldyBwcm9tcHQgd2l0aCB1c2VySWQgZXhwbGljaXRseSBzZXRcbiAgICBjb25zdCBuZXdQcm9tcHQgPSBhd2FpdCBwcm9tcHRSZXBvc2l0b3J5LmNyZWF0ZVByb21wdCh7XG4gICAgICAuLi5wcm9tcHREYXRhLFxuICAgICAgdXNlcklkLFxuICAgICAgY3JlYXRlZEJ5OiB1c2VyTmFtZVxuICAgIH0pO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCdTdWNjZXNzZnVsbHkgY3JlYXRlZCBwcm9tcHQ6JywgbmV3UHJvbXB0KTtcbiAgICBcbiAgICByZXR1cm4gcmVzLnN0YXR1cygyMDEpLmpzb24obmV3UHJvbXB0KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBwcm9tcHQ6JywgZXJyb3IpO1xuICAgIHJldHVybiByZXMuc3RhdHVzKDUwMCkuanNvbih7IG1lc3NhZ2U6ICdJbnRlcm5hbCBzZXJ2ZXIgZXJyb3InIH0pO1xuICB9XG59XG4iXSwibmFtZXMiOlsidmFsaWRhdGVQcm9tcHQiLCJ3aXRoQXV0aEZvck1ldGhvZHMiLCJwcm9tcHRSZXBvc2l0b3J5IiwiaXNUZWFtTWVtYmVyIiwiZ2V0VXNlclRlYW1zIiwiaGFuZGxlciIsInJlcSIsInJlcyIsInNldEhlYWRlciIsIm1ldGhvZCIsImdldFByb21wdHMiLCJhZGRQcm9tcHQiLCJzdGF0dXMiLCJqc29uIiwibWVzc2FnZSIsInVzZXJJZCIsInZpc2liaWxpdHkiLCJhaVBsYXRmb3JtIiwidGFncyIsInRlYW1JZCIsInF1ZXJ5IiwiZmlsdGVyIiwiQXJyYXkiLCJpc0FycmF5IiwiY3VycmVudFVzZXJJZCIsInNlc3Npb24iLCJzdWIiLCJwcm9tcHRzIiwiZ2V0QWxsUHJvbXB0cyIsInVzZXJUZWFtcyIsInRlYW0iLCJmaW5kIiwidCIsImlkIiwidXNlclRlYW1JZHMiLCJtYXAiLCJwcm9tcHQiLCJTdHJpbmciLCJpbmNsdWRlcyIsImVycm9yIiwiY29uc29sZSIsInByb21wdERhdGEiLCJib2R5IiwidXNlck5hbWUiLCJ1c2VyIiwibmFtZSIsImxvZyIsInNvbWUiLCJpc1ZhbGlkIiwiZXJyb3JzIiwibmV3UHJvbXB0IiwiY3JlYXRlUHJvbXB0IiwiY3JlYXRlZEJ5Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api-node)/./pages/api/prompts/index.js\n");

/***/ }),

/***/ "bcryptjs":
/*!***************************!*\
  !*** external "bcryptjs" ***!
  \***************************/
/***/ ((module) => {

module.exports = import("bcryptjs");;

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("crypto");

/***/ }),

/***/ "mongodb":
/*!**************************!*\
  !*** external "mongodb" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("mongodb");

/***/ }),

/***/ "next-auth/jwt":
/*!********************************!*\
  !*** external "next-auth/jwt" ***!
  \********************************/
/***/ ((module) => {

module.exports = require("next-auth/jwt");

/***/ }),

/***/ "next/dist/compiled/next-server/pages-api.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages-api.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/pages-api.runtime.dev.js");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(api-node)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fprompts&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cprompts%5Cindex.js&middlewareConfigBase64=e30%3D!")));
module.exports = __webpack_exports__;

})();